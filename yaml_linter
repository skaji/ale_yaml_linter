#!/usr/bin/env perl

# This chunk of stuff was generated by App::FatPacker. To find the original
# file's code, look for the end of this BEGIN block or the string 'FATPACK'
BEGIN {
my %fatpacked;

$fatpacked{"Module/Load.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'MODULE_LOAD';
  package Module::Load;use strict;use warnings;use File::Spec ();our$VERSION='0.36';sub import {my$who=_who();my$h;shift;{no strict 'refs';@_ or (*{"${who}::load"}=\&load,*{"${who}::autoload"}=\&autoload,return);map {$h->{$_}=()if defined $_}@_;(exists$h->{none}or exists$h->{''})and shift,last;((exists$h->{autoload}and shift,1)or (exists$h->{all}and shift))and *{"${who}::autoload"}=\&autoload;((exists$h->{load}and shift,1)or exists$h->{all})and *{"${who}::load"}=\&load;((exists$h->{load_remote}and shift,1)or exists$h->{all})and *{"${who}::load_remote"}=\&load_remote;((exists$h->{autoload_remote}and shift,1)or exists$h->{all})and *{"${who}::autoload_remote"}=\&autoload_remote}}sub load(*;@){goto&_load}sub autoload(*;@){unshift @_,'autoimport';goto&_load}sub load_remote($$;@){my ($dst,$src,@exp)=@_;eval "package $dst;Module::Load::load('$src', qw/@exp/);";$@ && die "$@"}sub autoload_remote($$;@){my ($dst,$src,@exp)=@_;eval "package $dst;Module::Load::autoload('$src', qw/@exp/);";$@ && die "$@"}sub _load{my$autoimport=$_[0]eq 'autoimport' and shift;my$mod=shift or return;my$who=_who();if(_is_file($mod)){require$mod}else {LOAD: {my$err;for my$flag (qw[1 0]){my$file=_to_file($mod,$flag);eval {require$file};$@ ? $err .= $@ : last LOAD}die$err if$err}}{no strict 'refs';my$import;((@_ or $autoimport)and ($import=$mod->can('import'))and (unshift(@_,$mod),goto &$import))}}sub _to_file{local $_=shift;my$pm=shift || '';my@parts=split /::|'/,$_,-1;shift@parts if@parts &&!$parts[0];my$file=$^O eq 'MSWin32' ? join "/",@parts : File::Spec->catfile(@parts);$file .= '.pm' if$pm;$file=VMS::Filespec::unixify($file)if $^O eq 'VMS';return$file}sub _who {(caller(1))[0]}sub _is_file {local $_=shift;return /^\./ ? 1 : /[^\w:']/ ? 1 : undef}1;
MODULE_LOAD

$fatpacked{"YAML/PP.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP';
  use strict;use warnings;package YAML::PP;our$VERSION='0.027';use YAML::PP::Schema;use YAML::PP::Schema::JSON;use YAML::PP::Loader;use YAML::PP::Dumper;use Scalar::Util qw/blessed/;use Carp qw/croak/;use base 'Exporter';our@EXPORT_OK=qw/Load LoadFile Dump DumpFile/;my%YAML_VERSIONS=('1.1'=>1,'1.2'=>1);sub new {my ($class,%args)=@_;my$bool=delete$args{boolean};$bool='perl' unless defined$bool;my$schemas=delete$args{schema}|| ['+'];my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$indent=delete$args{indent};my$width=delete$args{width};my$writer=delete$args{writer};my$header=delete$args{header};my$footer=delete$args{footer};my$duplicate_keys=delete$args{duplicate_keys};my$yaml_version=$class->_arg_yaml_version(delete$args{yaml_version});my$default_yaml_version=$yaml_version->[0];my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$parser=delete$args{parser};my$emitter=delete$args{emitter}|| {indent=>$indent,width=>$width,writer=>$writer,};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my%schemas;for my$v (@$yaml_version){my$schema;if (blessed($schemas)and $schemas->isa('YAML::PP::Schema')){$schema=$schemas}else {$schema=YAML::PP::Schema->new(boolean=>$bool,yaml_version=>$v,);$schema->load_subschemas(@$schemas)}$schemas{$v }=$schema}my$default_schema=$schemas{$default_yaml_version };my$loader=YAML::PP::Loader->new(schemas=>\%schemas,cyclic_refs=>$cyclic_refs,parser=>$parser,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$dumper=YAML::PP::Dumper->new(schema=>$default_schema,emitter=>$emitter,header=>$header,footer=>$footer,version_directive=>$version_directive,preserve=>$preserve,);my$self=bless {schema=>\%schemas,loader=>$loader,dumper=>$dumper,},$class;return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,loader=>$self->loader->clone,dumper=>$self->dumper->clone,};return bless$clone,ref$self}sub _arg_yaml_version {my ($class,$version)=@_;my@versions=('1.2');if (defined$version){@versions=();if (not ref$version){$version=[$version]}for my$v (@$version){unless ($YAML_VERSIONS{$v }){croak "YAML Version '$v' not supported"}push@versions,$v}}return \@versions}sub loader {if (@_ > 1){$_[0]->{loader}=$_[1]}return $_[0]->{loader}}sub dumper {if (@_ > 1){$_[0]->{dumper}=$_[1]}return $_[0]->{dumper}}sub schema {if (@_ > 1){$_[0]->{schema}->{'1.2'}=$_[1]}return $_[0]->{schema}->{'1.2'}}sub default_schema {my ($self,%args)=@_;my$schema=YAML::PP::Schema->new(boolean=>$args{boolean},);$schema->load_subschemas(qw/Core/);return$schema}sub load_string {my ($self,$yaml)=@_;return$self->loader->load_string($yaml)}sub load_file {my ($self,$file)=@_;return$self->loader->load_file($file)}sub dump {my ($self,@data)=@_;return$self->dumper->dump(@data)}sub dump_string {my ($self,@data)=@_;return$self->dumper->dump_string(@data)}sub dump_file {my ($self,$file,@data)=@_;return$self->dumper->dump_file($file,@data)}sub Load {my ($yaml)=@_;YAML::PP->new->load_string($yaml)}sub LoadFile {my ($file)=@_;YAML::PP->new->load_file($file)}sub Dump {my (@data)=@_;YAML::PP->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;YAML::PP->new->dump_file($file,@data)}sub preserved_scalar {my ($self,$value,%args)=@_;my$scalar=YAML::PP::Preserve::Scalar->new(value=>$value,%args,);return$scalar}sub preserved_mapping {my ($self,$hash,%args)=@_;my$data={};tie %$data,'YAML::PP::Preserve::Hash';%$data=%$hash;my$t=tied %$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}sub preserved_sequence {my ($self,$array,%args)=@_;my$data=[];tie @$data,'YAML::PP::Preserve::Array';push @$data,@$array;my$t=tied @$data;$t->{style}=$args{style};$t->{alias}=$args{alias};return$data}package YAML::PP::Preserve::Hash;use Tie::Hash;use base qw/Tie::StdHash/;sub TIEHASH {my ($class)=@_;my$self=bless {keys=>[],data=>{},},$class}sub STORE {my ($self,$key,$val)=@_;my$keys=$self->{keys};unless (exists$self->{data}->{$key }){push @$keys,$key}$self->{data}->{$key }=$val}sub FIRSTKEY {my ($self)=@_;return$self->{keys}->[0]}sub NEXTKEY {my ($self,$last)=@_;my$keys=$self->{keys};for my$i (0 .. $#$keys){if ("$keys->[ $i ]" eq "$last"){return$keys->[$i + 1 ]}}return}sub FETCH {my ($self,$key)=@_;my$val=$self->{data}->{$key }}sub DELETE {my ($self,$key)=@_;@{$self->{keys}}=grep {"$_" ne "$key"}@{$self->{keys}};delete$self->{data}->{$key }}sub EXISTS {my ($self,$key)=@_;return exists$self->{data}->{$key }}sub CLEAR {my ($self)=@_;$self->{keys}=[];$self->{data}={}}sub SCALAR {my ($self)=@_;return scalar %{$self->{data}}}package YAML::PP::Preserve::Array;use Tie::Array;use base qw/Tie::StdArray/;sub TIEARRAY {my ($class)=@_;my$self=bless {data=>[],},$class;return$self}sub FETCH {my ($self,$i)=@_;return$self->{data}->[$i ]}sub FETCHSIZE {my ($self)=@_;return $#{$self->{data}}+ 1}sub STORE {my ($self,$i,$val)=@_;$self->{data}->[$i ]=$val}sub PUSH {my ($self,@args)=@_;push @{$self->{data}},@args}sub STORESIZE {my ($self,$i)=@_;$#{$self->{data}}=$i - 1}sub DELETE {my ($self,$i)=@_;delete$self->{data}->[$i ]}sub EXISTS {my ($self,$i)=@_;return exists$self->{data}->[$i ]}sub CLEAR {my ($self)=@_;$self->{data}=[]}sub SHIFT {my ($self)=@_;shift @{$self->{data}}}sub UNSHIFT {my ($self,@args)=@_;unshift @{$self->{data}},@args}sub SPLICE {my ($self,$offset,$length,@args)=@_;splice @{$self->{data}},$offset,$length,@args}sub EXTEND {}package YAML::PP::Preserve::Scalar;use overload fallback=>1,'+'=>\&value,'""'=>\&value,'bool'=>\&value,;sub new {my ($class,%args)=@_;my$self={%args,};bless$self,$class}sub value {$_[0]->{value}}sub tag {$_[0]->{tag}}sub style {$_[0]->{style}|| 0}sub alias {$_[0]->{alias}}1;
YAML_PP

$fatpacked{"YAML/PP/Common.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_COMMON';
  use strict;use warnings;package YAML::PP::Common;our$VERSION='0.027';use base 'Exporter';our@EXPORT_OK=qw/YAML_ANY_SCALAR_STYLE YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_QUOTED_SCALAR_STYLE YAML_ANY_SEQUENCE_STYLE YAML_BLOCK_SEQUENCE_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_ANY_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_FLOW_MAPPING_STYLE PRESERVE_ALL PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use constant {YAML_ANY_SCALAR_STYLE=>0,YAML_PLAIN_SCALAR_STYLE=>1,YAML_SINGLE_QUOTED_SCALAR_STYLE=>2,YAML_DOUBLE_QUOTED_SCALAR_STYLE=>3,YAML_LITERAL_SCALAR_STYLE=>4,YAML_FOLDED_SCALAR_STYLE=>5,YAML_QUOTED_SCALAR_STYLE=>'Q',YAML_ANY_SEQUENCE_STYLE=>0,YAML_BLOCK_SEQUENCE_STYLE=>1,YAML_FLOW_SEQUENCE_STYLE=>2,YAML_ANY_MAPPING_STYLE=>0,YAML_BLOCK_MAPPING_STYLE=>1,YAML_FLOW_MAPPING_STYLE=>2,PRESERVE_ORDER=>2,PRESERVE_SCALAR_STYLE=>4,PRESERVE_FLOW_STYLE=>8,PRESERVE_ALIAS=>16,PRESERVE_ALL=>31,};my%scalar_style_to_string=(YAML_PLAIN_SCALAR_STYLE()=>':',YAML_SINGLE_QUOTED_SCALAR_STYLE()=>"'",YAML_DOUBLE_QUOTED_SCALAR_STYLE()=>'"',YAML_LITERAL_SCALAR_STYLE()=>'|',YAML_FOLDED_SCALAR_STYLE()=>'>',);sub event_to_test_suite {my ($event,$args)=@_;my$ev=$event->{name};my$string;my$content=$event->{value};my$properties='';$properties .= " &$event->{anchor}" if defined$event->{anchor};$properties .= " <$event->{tag}>" if defined$event->{tag};if ($ev eq 'document_start_event'){$string="+DOC";$string .= " ---" unless$event->{implicit}}elsif ($ev eq 'document_end_event'){$string="-DOC";$string .= " ..." unless$event->{implicit}}elsif ($ev eq 'stream_start_event'){$string="+STR"}elsif ($ev eq 'stream_end_event'){$string="-STR"}elsif ($ev eq 'mapping_start_event'){$string="+MAP";if ($event->{style}and $event->{style}eq YAML_FLOW_MAPPING_STYLE){$string .= ' {}' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'sequence_start_event'){$string="+SEQ";if ($event->{style}and $event->{style}eq YAML_FLOW_SEQUENCE_STYLE){$string .= ' []' if$args->{flow}}$string .= $properties;if (0){}}elsif ($ev eq 'mapping_end_event'){$string="-MAP"}elsif ($ev eq 'sequence_end_event'){$string="-SEQ"}elsif ($ev eq 'scalar_event'){$string='=VAL';$string .= $properties;$content =~ s/\\/\\\\/g;$content =~ s/\t/\\t/g;$content =~ s/\r/\\r/g;$content =~ s/\n/\\n/g;$content =~ s/[\b]/\\b/g;$string .= ' ' .$scalar_style_to_string{$event->{style}}.$content}elsif ($ev eq 'alias_event'){$string="=ALI *$content"}return$string}sub test_suite_to_event {my ($str)=@_;my$event={};if ($str =~ s/^\+STR//){$event->{name}='stream_start_event'}elsif ($str =~ s/^\-STR//){$event->{name}='stream_end_event'}elsif ($str =~ s/^\+DOC//){$event->{name}='document_start_event';if ($str =~ s/^ ---//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\-DOC//){$event->{name}='document_end_event';if ($str =~ s/^ \.\.\.//){$event->{implicit}=0}else {$event->{implicit}=1}}elsif ($str =~ s/^\+SEQ//){$event->{name}='sequence_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-SEQ//){$event->{name}='sequence_end_event'}elsif ($str =~ s/^\+MAP//){$event->{name}='mapping_start_event';if ($str =~ s/^ \&(\S+)//){$event->{anchor}=$1}if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}}elsif ($str =~ s/^\-MAP//){$event->{name}='mapping_end_event'}elsif ($str =~ s/^=VAL//){$event->{name}='scalar_event';if ($str =~ s/^ <(\S+)>//){$event->{tag}=$1}if ($str =~ s/^ [:'">|]//){$event->{style}=$1}if ($str =~ s/^(.*)//){$event->{value}=$1}}elsif ($str =~ s/^=ALI//){$event->{name}='alias_event';if ($str =~ s/^ \*(.*)//){$event->{value}=$1}}else {die "Could not parse event '$str'"}return$event}1;
YAML_PP_COMMON

$fatpacked{"YAML/PP/Constructor.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_CONSTRUCTOR';
  use strict;use warnings;package YAML::PP::Constructor;our$VERSION='0.027';use YAML::PP;use YAML::PP::Common qw/PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use Scalar::Util qw/reftype/;use Carp qw/croak/;use constant DEBUG=>($ENV{YAML_PP_LOAD_DEBUG}or $ENV{YAML_PP_LOAD_TRACE})? 1 : 0;use constant TRACE=>$ENV{YAML_PP_LOAD_TRACE}? 1 : 0;my%cyclic_refs=qw/allow 1 ignore 1 warn 1 fatal 1/;sub new {my ($class,%args)=@_;my$default_yaml_version=delete$args{default_yaml_version};my$duplicate_keys=delete$args{duplicate_keys};unless (defined$duplicate_keys){$duplicate_keys=0}my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';die "Invalid value for cyclic_refs: $cyclic_refs" unless$cyclic_refs{$cyclic_refs };my$schemas=delete$args{schemas};if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {default_yaml_version=>$default_yaml_version,schemas=>$schemas,cyclic_refs=>$cyclic_refs,preserve=>$preserve,duplicate_keys=>$duplicate_keys,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={schemas=>$self->{schemas},schema=>$self->{schema},default_yaml_version=>$self->{default_yaml_version},cyclic_refs=>$self->cyclic_refs,preserve=>$self->{preserve},};return bless$clone,ref$self}sub init {my ($self)=@_;$self->set_docs([]);$self->set_stack([]);$self->set_anchors({});$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->yaml_version })}sub docs {return $_[0]->{docs}}sub stack {return $_[0]->{stack}}sub anchors {return $_[0]->{anchors}}sub set_docs {$_[0]->{docs}=$_[1]}sub set_stack {$_[0]->{stack}=$_[1]}sub set_anchors {$_[0]->{anchors}=$_[1]}sub schemas {return $_[0]->{schemas}}sub schema {return $_[0]->{schema}}sub set_schema {$_[0]->{schema}=$_[1]}sub cyclic_refs {return $_[0]->{cyclic_refs}}sub set_cyclic_refs {$_[0]->{cyclic_refs}=$_[1]}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub duplicate_keys {return $_[0]->{duplicate_keys}}sub document_start_event {my ($self,$event)=@_;my$stack=$self->stack;if ($event->{version_directive}){my$version=$event->{version_directive};$version="$version->{major}.$version->{minor}";if ($self->{schemas}->{$version }){$self->set_yaml_version($version);$self->set_schema($self->schemas->{$version })}else {$self->set_yaml_version($self->default_yaml_version);$self->set_schema($self->schemas->{$self->default_yaml_version })}}my$ref=[];push @$stack,{type=>'document',ref=>$ref,data=>$ref,event=>$event }}sub document_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'document' or die "Expected mapping, but got $last->{type}";if (@$stack){die "Got unexpected end of document"}my$docs=$self->docs;push @$docs,$last->{ref}->[0];$self->set_anchors({});$self->set_stack([])}sub mapping_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_mapping($self,$event);my$ref={type=>'mapping',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_order=$self->preserve_order;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if (($preserve_order or $preserve_style or $preserve_alias)and not tied(%$data)){tie %$data,'YAML::PP::Preserve::Hash'}if ($preserve_style){my$t=tied %$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied %$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub mapping_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;my ($ref,$data)=@{$last}{qw/ref data/};$last->{type}eq 'mapping' or die "Expected mapping, but got $last->{type}";my@merge_keys;my@ref;for (my$i=0;$i < @$ref;$i += 2){my$key=$ref->[$i ];if (ref$key eq 'YAML::PP::Type::MergeKey'){my$merge=$ref->[$i + 1 ];if ((reftype($merge)|| '')eq 'HASH'){push@merge_keys,$merge}elsif ((reftype($merge)|| '')eq 'ARRAY'){for my$item (@$merge){if ((reftype($item)|| '')eq 'HASH'){push@merge_keys,$item}else {die "Expected hash for merge key"}}}else {die "Expected hash or array for merge key"}}else {push@ref,$key,$ref->[$i + 1 ]}}for my$merge (@merge_keys){for my$key (keys %$merge){unless (exists $$data->{$key }){$$data->{$key }=$merge->{$key }}}}my$on_data=$last->{on_data}|| sub {my ($self,$hash,$items)=@_;my%seen;for (my$i=0;$i < @$items;$i += 2){my ($key,$value)=@$items[$i,$i + 1 ];$key='' unless defined$key;if (ref$key){$key=$self->stringify_complex($key)}if ($seen{$key }++ and not $self->duplicate_keys){croak "Duplicate key '$key'"}$$hash->{$key }=$value}};$on_data->($self,$data,\@ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){$self->anchors->{$anchor }->{finished}=1}return}sub sequence_start_event {my ($self,$event)=@_;my ($data,$on_data)=$self->schema->create_sequence($self,$event);my$ref={type=>'sequence',ref=>[],data=>\$data,event=>$event,on_data=>$on_data,};my$stack=$self->stack;my$preserve_style=$self->preserve_flow_style;my$preserve_alias=$self->preserve_alias;if ($preserve_style or $preserve_alias and not tied(@$data)){tie @$data,'YAML::PP::Preserve::Array',@$data;my$t=tied @$data;$t->{style}=$event->{style}}push @$stack,$ref;if (defined(my$anchor=$event->{anchor})){if ($preserve_alias){my$t=tied @$data;unless (exists$self->anchors->{$anchor }){$t->{alias}=$anchor}}$self->anchors->{$anchor }={data=>$ref->{data}}}}sub sequence_end_event {my ($self,$event)=@_;my$stack=$self->stack;my$last=pop @$stack;$last->{type}eq 'sequence' or die "Expected mapping, but got $last->{type}";my ($ref,$data)=@{$last}{qw/ref data/};my$on_data=$last->{on_data}|| sub {my ($self,$array,$items)=@_;push @$$array,@$items};$on_data->($self,$data,$ref);push @{$stack->[-1]->{ref}},$$data;if (defined(my$anchor=$last->{event}->{anchor})){my$test=$self->anchors->{$anchor };$self->anchors->{$anchor }->{finished}=1}return}sub stream_start_event {}sub stream_end_event {}sub scalar_event {my ($self,$event)=@_;DEBUG and warn "CONTENT $event->{value} ($event->{style})\n";my$value=$self->schema->load_scalar($self,$event);my$last=$self->stack->[-1];my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if (($preserve_style or $preserve_alias)and not ref$value){my%args=(value=>$value,tag=>$event->{tag},);if ($preserve_style){$args{style}=$event->{style}}if ($preserve_alias and defined$event->{anchor}){my$anchor=$event->{anchor};unless (exists$self->anchors->{$anchor }){$args{alias}=$event->{anchor}}}$value=YAML::PP::Preserve::Scalar->new(%args)}if (defined (my$name=$event->{anchor})){$self->anchors->{$name }={data=>\$value,finished=>1 }}push @{$last->{ref}},$value}sub alias_event {my ($self,$event)=@_;my$value;my$name=$event->{value};if (my$anchor=$self->anchors->{$name }){unless ($anchor->{finished}){my$cyclic_refs=$self->cyclic_refs;if ($cyclic_refs ne 'allow'){if ($cyclic_refs eq 'fatal'){die "Found cyclic ref for alias '$name'"}if ($cyclic_refs eq 'warn'){$anchor={data=>\undef };warn "Found cyclic ref for alias '$name'"}elsif ($cyclic_refs eq 'ignore'){$anchor={data=>\undef }}}}$value=$anchor->{data}}else {croak "No anchor defined for alias '$name'"}my$last=$self->stack->[-1];push @{$last->{ref}},$$value}sub stringify_complex {my ($self,$data)=@_;return$data if (ref$data eq 'YAML::PP::Preserve::Scalar' and ($self->preserve_scalar_style or $self->preserve_alias));require Data::Dumper;local$Data::Dumper::Quotekeys=0;local$Data::Dumper::Terse=1;local$Data::Dumper::Indent=0;local$Data::Dumper::Useqq=0;local$Data::Dumper::Sortkeys=1;my$string=Data::Dumper->Dump([$data],['data']);$string =~ s/^\$data = //;return$string}1;
YAML_PP_CONSTRUCTOR

$fatpacked{"YAML/PP/Dumper.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_DUMPER';
  use strict;use warnings;package YAML::PP::Dumper;our$VERSION='0.027';use Scalar::Util qw/blessed refaddr reftype/;use YAML::PP;use YAML::PP::Emitter;use YAML::PP::Representer;use YAML::PP::Writer;use YAML::PP::Writer::File;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE/;sub new {my ($class,%args)=@_;my$header=delete$args{header};$header=1 unless defined$header;my$footer=delete$args{footer};$footer=0 unless defined$footer;my$version_directive=delete$args{version_directive};my$preserve=delete$args{preserve};my$schema=delete$args{schema}|| YAML::PP->default_schema(boolean=>'perl',);my$emitter=delete$args{emitter}|| YAML::PP::Emitter->new;unless (blessed($emitter)){$emitter=YAML::PP::Emitter->new(%$emitter)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {representer=>YAML::PP::Representer->new(schema=>$schema,preserve=>$preserve,),version_directive=>$version_directive,emitter=>$emitter,seen=>{},anchors=>{},anchor_num=>0,header=>$header,footer=>$footer,},$class;return$self}sub clone {my ($self)=@_;my$clone={representer=>$self->representer->clone,emitter=>$self->emitter->clone,version_directive=>$self->version_directive,seen=>{},anchors=>{},anchor_num=>0,header=>$self->header,footer=>$self->footer,};return bless$clone,ref$self}sub init {my ($self)=@_;$self->{seen}={};$self->{anchors}={};$self->{anchor_num}=0}sub emitter {return $_[0]->{emitter}}sub representer {return $_[0]->{representer}}sub set_representer {$_[0]->{representer}=$_[1]}sub header {return $_[0]->{header}}sub footer {return $_[0]->{footer}}sub version_directive {return $_[0]->{version_directive}}sub dump {my ($self,@docs)=@_;$self->emitter->init;$self->emitter->stream_start_event({});for my$i (0 .. $#docs){my$header_implicit=($i==0 and not $self->header);my%args=(implicit=>$header_implicit,);if ($self->version_directive){my ($major,$minor)=split m/\./,$self->representer->schema->yaml_version;$args{version_directive}={major=>$major,minor=>$minor }}$self->emitter->document_start_event(\%args);$self->init;$self->check_references($docs[$i ]);$self->dump_node($docs[$i ]);my$footer_implicit=(not $self->footer);$self->emitter->document_end_event({implicit=>$footer_implicit })}$self->emitter->stream_end_event({});my$output=$self->emitter->writer->output;$self->emitter->finish;return$output}sub dump_node {my ($self,$value)=@_;my$node={value=>$value,};if (ref$value){my$seen=$self->{seen};my$refaddr=refaddr$value;if ($seen->{$refaddr }and $seen->{$refaddr }> 1){my$anchor=$self->{anchors}->{$refaddr };unless (defined$anchor){if ($self->representer->preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){if (defined$node->{value}->alias){$node->{anchor}=$node->{value}->alias;$self->{anchors}->{$refaddr }=$node->{value}->alias}}elsif (reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}elsif (reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){if (defined$tied->{alias}){$node->{anchor}=$tied->{alias};$self->{anchors}->{$refaddr }=$node->{anchor}}}}}unless (defined$node->{anchor}){my$num=++$self->{anchor_num};$self->{anchors}->{$refaddr }=$num;$node->{anchor}=$num}}else {$node->{value}=$anchor;$self->emit_node([alias=>$node ]);return}}}$node=$self->representer->represent_node($node);$self->emit_node($node)}sub emit_node {my ($self,$item)=@_;my ($type,$node,%args)=@$item;if ($type eq 'alias'){$self->emitter->alias_event({value=>$node->{value}});return}if ($type eq 'mapping'){my$style=$args{style}|| YAML_BLOCK_MAPPING_STYLE;if ($node->{items}and @{$node->{items}}==0){}$self->emitter->mapping_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->dump_node($_)}$self->emitter->mapping_end_event;return}if ($type eq 'sequence'){my$style=$args{style}|| YAML_BLOCK_SEQUENCE_STYLE;if (@{$node->{items}}==0){}$self->emitter->sequence_start_event({anchor=>$node->{anchor},style=>$style,tag=>$node->{tag},});for (@{$node->{items}}){$self->dump_node($_)}$self->emitter->sequence_end_event;return}$self->emitter->scalar_event({value=>$node->{items}->[0],style=>$node->{style},anchor=>$node->{anchor},tag=>$node->{tag},})}sub dump_string {my ($self,@docs)=@_;my$writer=YAML::PP::Writer->new;$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}sub dump_file {my ($self,$file,@docs)=@_;my$writer=YAML::PP::Writer::File->new(output=>$file);$self->emitter->set_writer($writer);my$output=$self->dump(@docs);return$output}my%_reftypes=(HASH=>1,ARRAY=>1,Regexp=>1,REGEXP=>1,CODE=>1,SCALAR=>1,REF=>1,GLOB=>1,);sub check_references {my ($self,$doc)=@_;my$reftype=reftype$doc or return;my$seen=$self->{seen};if ($reftype eq 'SCALAR' and ref$doc eq $self->representer->schema->bool_class){if (ref$doc eq 'boolean' or ref$doc eq 'JSON::PP::Boolean'){return}}if (++$seen->{refaddr$doc }> 1){return}unless ($_reftypes{$reftype }){die sprintf "Reference %s not implemented",$reftype}if ($reftype eq 'HASH'){$self->check_references($doc->{$_ })for keys %$doc}elsif ($reftype eq 'ARRAY'){$self->check_references($_)for @$doc}elsif ($reftype eq 'REF'){$self->check_references($$doc)}}1;
YAML_PP_DUMPER

$fatpacked{"YAML/PP/Emitter.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EMITTER';
  use strict;use warnings;package YAML::PP::Emitter;our$VERSION='0.027';use Data::Dumper;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use constant DEBUG=>$ENV{YAML_PP_EMIT_DEBUG}? 1 : 0;use constant DEFAULT_WIDTH=>80;sub new {my ($class,%args)=@_;my$self=bless {indent=>$args{indent}|| 2,writer=>$args{writer},width=>$args{width}|| DEFAULT_WIDTH,},$class;$self->init;return$self}sub clone {my ($self)=@_;my$clone={indent=>$self->indent,};return bless$clone,ref$self}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub indent {return $_[0]->{indent}}sub width {return $_[0]->{width}}sub line {return $_[0]->{line}}sub column {return $_[0]->{column}}sub set_indent {$_[0]->{indent}=$_[1]}sub writer {$_[0]->{writer}}sub set_writer {$_[0]->{writer}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub init {my ($self)=@_;unless ($self->writer){$self->set_writer(YAML::PP::Writer->new)}$self->set_tagmap({'tag:yaml.org,2002:'=>'!!',});$self->{open_ended}=0;$self->{line}=0;$self->{column}=0;$self->writer->init}sub mapping_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('map',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if ($info->{style}|| 0)eq YAML_FLOW_MAPPING_STYLE;my$newline=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$new_indent .= ' ' x $self->indent;$newline=1}else {$new_indent=$indent;if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= '-'}elsif ($last->{type}eq 'MAP'){$yaml .= "?";$last->{type}='COMPLEX'}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":"}else {die "Should not happen ($last->{type} in mapping_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);my$new_info={index=>0,indent=>$new_indent,info=>$info,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='MAP';push @{$stack},$new_info;$last->{index}++;$self->{open_ended}=0}sub mapping_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ mapping_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}if ($self->column){$self->_write(" {}\n")}else {$self->_write("$indent\{}\n")}}elsif ($last->{flow}){my$yaml="}";if ($last->{flow}==1){$yaml .= "\n"}$self->_write("$yaml")}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}sub sequence_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_start_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$new_indent=$indent;my$yaml='';my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('seq',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$flow=$last->{flow}|| 0;$flow++ if$flow or ($info->{style}|| 0)eq YAML_FLOW_SEQUENCE_STYLE;my$newline=0;my$zero_indent=0;if ($flow > 1){if ($last->{type}eq 'SEQ'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "["}else {$yaml .= ","}}elsif ($last->{type}eq 'MAP'){if ($last->{newline}){$yaml .= ' '}if ($last->{index}==0){$yaml .= "{"}else {$yaml .= ","}}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": "}if ($props){$yaml .= " $props "}$new_indent .= ' ' x $self->indent}else {if ($last->{type}eq 'DOC'){$newline=$last->{newline}}else {if ($last->{newline}){$yaml .= "\n";$last->{column}=0}if ($last->{type}eq 'MAPVALUE'){$zero_indent=1;$newline=1}else {if (not $props and $self->indent==1){$new_indent .= ' ' x 2}else {$new_indent .= ' ' x $self->indent}if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'SEQ'){$yaml .= "-"}elsif ($last->{type}eq 'MAP'){$last->{type}='COMPLEX';$zero_indent=1;$yaml .= "?"}elsif ($last->{type}eq 'COMPLEXVALUE'){$yaml .= ":";$zero_indent=1}else {die "Should not happen ($last->{type} in sequence_start)"}$last->{column}=1}$last->{newline}=0}if ($props){$yaml .= $last->{column}? ' ' : $indent;$yaml .= $props;$newline=1}}$self->_write($yaml);$last->{index}++;my$new_info={index=>0,indent=>$new_indent,info=>$info,zero_indent=>$zero_indent,newline=>$newline,column=>$self->column,flow=>$flow,};$new_info->{type}='SEQ';push @{$stack},$new_info;$self->{open_ended}=0}sub sequence_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ sequence_end_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=pop @{$stack};if ($last->{index}==0){my$indent=$last->{indent};my$zero_indent=$last->{zero_indent};if ($last->{zero_indent}){$indent .= ' ' x $self->indent}my$yaml .= $self->column ? ' ' : $indent;$yaml .= "[]";if ($last->{flow}< 2){$yaml .= "\n"}$self->_write($yaml)}elsif ($last->{flow}){my$yaml="]";if ($last->{flow}==1){$yaml .= "\n"}$self->_write($yaml)}$last=$stack->[-1];$last->{column}=$self->column;if ($last->{type}eq 'SEQ'){}elsif ($last->{type}eq 'MAP'){$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'COMPLEX'){$last->{type}='COMPLEXVALUE'}elsif ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP'}}my%forbidden_first=(qw/! 1 & 1 * 1 { 1 } 1 [ 1 ] 1 | 1 > 1 @ 1 ` 1 " 1 ' 1/,'#'=>1,'%'=>1,','=>1," "=>1);my%forbidden_first_plus_space=(qw/? 1 - 1 : 1/);my%control=("\x00"=>'\0',"\x01"=>'\x01',"\x02"=>'\x02',"\x03"=>'\x03',"\x04"=>'\x04',"\x05"=>'\x05',"\x06"=>'\x06',"\x07"=>'\a',"\x08"=>'\b',"\x0b"=>'\v',"\x0c"=>'\f',"\x0e"=>'\x0e',"\x0f"=>'\x0f',"\x10"=>'\x10',"\x11"=>'\x11',"\x12"=>'\x12',"\x13"=>'\x13',"\x14"=>'\x14',"\x15"=>'\x15',"\x16"=>'\x16',"\x17"=>'\x17',"\x18"=>'\x18',"\x19"=>'\x19',"\x1a"=>'\x1a',"\x1b"=>'\e',"\x1c"=>'\x1c',"\x1d"=>'\x1d',"\x1e"=>'\x1e',"\x1f"=>'\x1f',"\x7f"=>'\x7f',"\x80"=>'\x80',"\x81"=>'\x81',"\x82"=>'\x82',"\x83"=>'\x83',"\x84"=>'\x84',"\x86"=>'\x86',"\x87"=>'\x87',"\x88"=>'\x88',"\x89"=>'\x89',"\x8a"=>'\x8a',"\x8b"=>'\x8b',"\x8c"=>'\x8c',"\x8d"=>'\x8d',"\x8e"=>'\x8e',"\x8f"=>'\x8f',"\x90"=>'\x90',"\x91"=>'\x91',"\x92"=>'\x92',"\x93"=>'\x93',"\x94"=>'\x94',"\x95"=>'\x95',"\x96"=>'\x96',"\x97"=>'\x97',"\x98"=>'\x98',"\x99"=>'\x99',"\x9a"=>'\x9a',"\x9b"=>'\x9b',"\x9c"=>'\x9c',"\x9d"=>'\x9d',"\x9e"=>'\x9e',"\x9f"=>'\x9f',"\x{2029}"=>'\P',"\x{2028}"=>'\L',"\x85"=>'\N',"\xa0"=>'\_',);my$control_re='\x00-\x08\x0b\x0c\x0e-\x1f\x7f-\x84\x86-\x9f\x{d800}-\x{dfff}\x{fffe}\x{ffff}\x{2028}\x{2029}\x85\xa0';my%to_escape=("\n"=>'\n',"\t"=>'\t',"\r"=>'\r','\\'=>'\\\\','"'=>'\\"',%control,);my$escape_re=$control_re .'\n\t\r';my$escape_re_without_lb=$control_re .'\t\r';sub scalar_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ scalar_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$value=$info->{value};my$flow=$last->{flow};my$props='';my$anchor=$info->{anchor};my$tag=$info->{tag};if (defined$anchor){$anchor="&$anchor"}if (defined$tag){$tag=$self->emit_tag('scalar',$tag)}$props=join ' ',grep defined,($anchor,$tag);my$style=$info->{style};DEBUG and local$Data::Dumper::Useqq=1;$value='' unless defined$value;my$first=substr($value,0,1);if ($value eq ''){if ($flow and $last->{type}ne 'MAPVALUE' and $last->{type}ne 'MAP'){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (not $style){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}elsif ($value =~ m/[$control_re]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}$style ||= YAML_PLAIN_SCALAR_STYLE;if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){if ($value =~ m/ \n/ or $value =~ m/\n / or $value =~ m/^\n/ or $value =~ m/\n$/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}elsif ($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE){if ($value eq ''){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($flow){if ($value =~ tr/\n//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}else {$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}elsif ($style==YAML_PLAIN_SCALAR_STYLE){if (not length$value){}elsif ($value =~ m/[$escape_re_without_lb]/){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value eq "\n"){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ //c){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value !~ tr/ \n//c){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}elsif ($value =~ tr/\n//){$style=$flow ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_LITERAL_SCALAR_STYLE}elsif ($forbidden_first{$first }){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($flow and $value =~ tr/,[]{}//){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif (substr($value,0,3)=~ m/^(?:---|\.\.\.)/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/: /){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/ #/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[: \t]\z/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($value =~ m/[^\x20-\x3A\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}elsif ($forbidden_first_plus_space{$first }){if (length ($value)==1 or substr($value,1,1)=~ m/^\s/){$style=YAML_SINGLE_QUOTED_SCALAR_STYLE}}}if ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE and not $info->{style}){if ($value =~ tr/'// and $value !~ tr/"//){$style=YAML_DOUBLE_QUOTED_SCALAR_STYLE}}my$open_ended=0;if ($style==YAML_PLAIN_SCALAR_STYLE){$value =~ s/\n/\n\n/g}elsif ($style==YAML_SINGLE_QUOTED_SCALAR_STYLE){my$new_indent=$last->{indent}.(' ' x $self->indent);$value =~ s/(\n+)/"\n" x (1 + (length $1))/eg;my@lines=split m/\n/,$value,-1;if (@lines > 1){for my$line (@lines[1 .. $#lines]){$line=$new_indent .$line if length$line}}$value=join "\n",@lines;$value =~ s/'/''/g;$value="'" .$value ."'"}elsif ($style==YAML_LITERAL_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($value !~ m/\n\z/){$indicators .= '-';$value .= "\n"}elsif ($value =~ m/(\n|\A)\n\z/){$indicators .= '+';$open_ended=1}$value =~ s/^(?=.)/$indent/gm;$value="|$indicators\n$value"}elsif ($style==YAML_FOLDED_SCALAR_STYLE){DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$value],['value']);my@lines=split /\n/,$value,-1;DEBUG and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\@lines],['lines']);my$eol=0;my$indicators='';if ($value =~ m/\A\n* +/){$indicators .= $self->indent}my$indent=$indent .' ' x $self->indent;if ($lines[-1]eq ''){pop@lines;$eol=1}else {$indicators .= '-'}$value=">$indicators\n";for my$i (0 .. $#lines){my$line=$lines[$i ];if (length$line){$value .= "$indent$line\n"}if ($i!=$#lines){$value .= "\n"}}}else {$value =~ s/([$escape_re"\\])/$to_escape{ $1 } || sprintf '\\u%04x', ord($1)/eg;$value='"' .$value .'"'}DEBUG and warn __PACKAGE__.':'.__LINE__.": (@$stack)\n";my$yaml='';my$pvalue=$props;if ($props and length$value){$pvalue .= " $value"}elsif (length$value){$pvalue .= $value}my$multiline=($style==YAML_LITERAL_SCALAR_STYLE or $style==YAML_FOLDED_SCALAR_STYLE);my$newline=0;if ($flow){$indent=0;if ($props and not length$value){$pvalue .= ' '}if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($self->column){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE'}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die "Should not happen (index 0 in MAPVALUE)"}$yaml .= ": ";$last->{type}='MAP'}if ($self->column + length$pvalue > $self->width){$yaml .= "\n";$yaml .= $last->{indent};$yaml .= ' ' x $self->indent}$yaml .= $pvalue}else {if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}my$space=' ';if ($last->{type}eq 'MAP'){if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($props and not length$value){$pvalue .= ' '}my$new_event='MAPVALUE';$last->{type}=$new_event;if ($multiline){$yaml .= "? ";$new_event='COMPLEXVALUE';$last->{type}=$new_event}if (not $multiline){$pvalue .= ":"}}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{column}){my$space=$self->indent > 1 ? ' ' x ($self->indent - 1): ' ';$yaml .= $space}else {$yaml .= $indent}if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ":"}elsif ($last->{type}eq 'SEQ'){$yaml .= "-"}else {die "Should not happen ($last->{type} in scalar_event)"}$last->{column}=1}if (length$pvalue){if ($last->{column}){$pvalue="$space$pvalue"}}if (not $multiline){$pvalue .= "\n"}}$yaml .= $pvalue}$last->{index}++;$last->{newline}=$newline;$self->_write($yaml);$last->{column}=$self->column;$self->{open_ended}=$open_ended}sub alias_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ alias_event\n";my ($self,$info)=@_;my$stack=$self->event_stack;my$last=$stack->[-1];my$indent=$last->{indent};my$flow=$last->{flow};my$alias='*' .$info->{value};my$yaml='';if ($last->{type}eq 'MAP' or $last->{type}eq 'SEQ'){if ($last->{index}==0 and $last->{newline}){$yaml .= "\n";$last->{column}=0;$last->{newline}=0}}$yaml .= $last->{column}? ' ' : $indent;if ($flow){my$space='';if ($last->{type}eq 'SEQ'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "["}else {$yaml .= ", "}}elsif ($last->{type}eq 'MAP'){if ($last->{index}==0){if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ", "}$last->{type}='MAPVALUE';$space=' '}elsif ($last->{type}eq 'MAPVALUE'){if ($last->{index}==0){die 23;if ($flow==1){$yaml .= ' '}$yaml .= "{"}else {$yaml .= ": "}$last->{type}='MAP'}$yaml .= "$alias$space"}else {if ($last->{type}eq 'MAP'){$yaml .= "$alias :";$last->{type}='MAPVALUE'}else {if ($last->{type}eq 'MAPVALUE'){$last->{type}='MAP'}elsif ($last->{type}eq 'DOC'){}else {if ($last->{type}eq 'COMPLEXVALUE'){$last->{type}='MAP';$yaml .= ": "}elsif ($last->{type}eq 'COMPLEX'){$yaml .= ": "}elsif ($last->{type}eq 'SEQ'){$yaml .= "- "}else {die "Unexpected"}}$yaml .= "$alias\n"}}$self->_write("$yaml");$last->{index}++;$last->{column}=$self->column;$self->{open_ended}=0}sub document_start_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_start_event\n";my ($self,$info)=@_;my$newline=0;my$implicit=$info->{implicit};if ($info->{version_directive}){if ($self->{open_ended}){$self->_write("...\n")}$self->_write("%YAML $info->{version_directive}->{major}.$info->{version_directive}->{minor}\n");$self->{open_ended}=0;$implicit=0}unless ($implicit){$newline=1;$self->_write("---")}$self->set_event_stack([{type=>'DOC',index=>0,indent=>'',info=>$info,newline=>$newline,column=>$self->column,}])}sub document_end_event {DEBUG and warn __PACKAGE__.':'.__LINE__.": +++ document_end_event\n";my ($self,$info)=@_;$self->set_event_stack([]);if ($self->{open_ended}or not $info->{implicit}){$self->_write("...\n");$self->{open_ended}=0}else {$self->{open_ended}=1}}sub stream_start_event {}sub stream_end_event {}sub emit_tag {my ($self,$type,$tag)=@_;my$map=$self->tagmap;for my$key (sort keys %$map){if ($tag =~ m/^\Q$key\E(.*)/){$tag=$map->{$key }.$1;return$tag}}if ($tag =~ m/^(!.*)/){$tag="$1"}else {$tag="!<$tag>"}return$tag}sub finish {my ($self)=@_;$self->writer->finish}sub _write {my ($self,$yaml)=@_;return unless length$yaml;my@lines=split m/\n/,$yaml,-1;my$newlines=@lines - 1;$self->{line}+= $newlines;if (length$lines[-1]){if ($newlines){$self->{column}=length$lines[-1]}else {$self->{column}+= length$lines[-1]}}else {$self->{column}=0}$self->writer->write($yaml)}1;
YAML_PP_EMITTER

$fatpacked{"YAML/PP/Exception.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_EXCEPTION';
  use strict;use warnings;package YAML::PP::Exception;our$VERSION='0.027';use overload '""'=>\&to_string;sub new {my ($class,%args)=@_;my$self=bless {line=>$args{line},msg=>$args{msg},next=>$args{next},where=>$args{where},yaml=>$args{yaml},got=>$args{got},expected=>$args{expected},column=>$args{column},},$class;return$self}sub to_string {my ($self)=@_;my$next=$self->{next};my$line=$self->{line};my$column=$self->{column};my$yaml='';for my$token (@$next){last if$token->{name}eq 'EOL';$yaml .= $token->{value}}$column='???' unless defined$column;my$remaining_yaml=$self->{yaml};$remaining_yaml='' unless defined$remaining_yaml;$yaml .= $remaining_yaml;{local $@;require Data::Dumper;local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;$yaml=Data::Dumper->Dump([$yaml],['yaml']);chomp$yaml}my$lines=5;my@fields;if ($self->{got}and $self->{expected}){$lines=6;$line=$self->{got}->{line};$column=$self->{got}->{column}+ 1;@fields=("Line"=>$line,"Column"=>$column,"Expected",join(" ",@{$self->{expected}}),"Got",$self->{got}->{name},"Where",$self->{where},"YAML",$yaml,)}else {@fields=("Line"=>$line,"Column"=>$column,"Message",$self->{msg},"Where",$self->{where},"YAML",$yaml,)}my$fmt=join "\n",("%-10s: %s")x $lines;my$string=sprintf$fmt,@fields;return$string}1;
YAML_PP_EXCEPTION

$fatpacked{"YAML/PP/Grammar.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_GRAMMAR';
  use strict;use warnings;package YAML::PP::Grammar;our$VERSION='0.027';use base 'Exporter';our@EXPORT_OK=qw/$GRAMMAR/;our$GRAMMAR={};$GRAMMAR={'DIRECTIVE'=>{'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'DIRECTIVE' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }},'DOCUMENT_END'=>{'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'DOCUMENT_END' }},'FLOWMAP'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'match'=>'cb_flowkey_plain','return'=>1 },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'match'=>'cb_flowkey_quoted','return'=>1 },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'FLOWSEQ'=>{'ALIAS'=>{'match'=>'cb_send_flow_alias','new'=>'FLOWSEQ_NEXT' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'match'=>'cb_flow_plain','new'=>'FLOWSEQ_NEXT' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','new'=>'FLOWSEQ_NEXT' },'QUOTED'=>{'match'=>'cb_flowkey_quoted','new'=>'FLOWSEQ_NEXT' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','new'=>'FLOWSEQ_NEXT' }},'FLOWSEQ_NEXT'=>{'EOL'=>{'new'=>'FLOWSEQ_NEXT' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','return'=>1 },'WS'=>{'new'=>'FLOWSEQ_NEXT' }},'FULLMAPVALUE_INLINE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_MAPVALUE_INLINE' }},'match'=>'cb_tag' }},'FULLNODE'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG' },'WS'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_ANCHOR' },'TAG'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG'=>{'ANCHOR'=>{'EOL'=>{'match'=>'cb_property_eol','new'=>'FULLNODE_TAG_ANCHOR' },'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'FULLNODE_TAG_ANCHOR'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'TAG'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_NODE' },'EOL'=>{'new'=>'FULLNODE_TAG_ANCHOR' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'match'=>'cb_tag' }},'NEWFLOWMAP'=>{'ANCHOR'=>{'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR' },'match'=>'cb_anchor' },'COLON'=>{'EOL'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'match'=>'cb_empty_flow_mapkey','new'=>'RULE_FULLFLOWSCALAR' }},'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'NEWFLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'QUESTION'=>{'match'=>'cb_flow_question','new'=>'NEWFLOWMAP' },'TAG'=>{'EOL'=>{'new'=>'NEWFLOWMAP_TAG' },'WS'=>{'new'=>'NEWFLOWMAP_TAG' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWMAP' }},'NEWFLOWMAP_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'NEWFLOWMAP_ANCHOR' },'TAG'=>{'EOL'=>{'new'=>'FLOWMAP' },'WS'=>{'new'=>'FLOWMAP' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWMAP_ANCHOR' }},'NEWFLOWMAP_TAG'=>{'ANCHOR'=>{'EOL'=>{'new'=>'FLOWMAP' },'WS'=>{'new'=>'FLOWMAP' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWMAP' },'EOL'=>{'new'=>'NEWFLOWMAP_TAG' },'WS'=>{'new'=>'NEWFLOWMAP_TAG' }},'NEWFLOWSEQ'=>{'ANCHOR'=>{'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ' },'EOL'=>{'new'=>'NEWFLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'TAG'=>{'EOL'=>{'new'=>'NEWFLOWSEQ_TAG' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ' }},'NEWFLOWSEQ_ANCHOR'=>{'DEFAULT'=>{'new'=>'FLOWSEQ' },'EOL'=>{'new'=>'NEWFLOWSEQ_ANCHOR' },'TAG'=>{'EOL'=>{'new'=>'FLOWSEQ' },'WS'=>{'new'=>'FLOWSEQ' },'match'=>'cb_tag' },'WS'=>{'new'=>'NEWFLOWSEQ_ANCHOR' }},'NEWFLOWSEQ_TAG'=>{'ANCHOR'=>{'EOL'=>{'new'=>'FLOWSEQ' },'WS'=>{'new'=>'FLOWSEQ' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'FLOWSEQ' },'EOL'=>{'new'=>'NEWFLOWSEQ_TAG' },'WS'=>{'new'=>'NEWFLOWSEQ_TAG' }},'NODETYPE_COMPLEX'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_complexcolon' },'DEFAULT'=>{'match'=>'cb_empty_complexvalue','new'=>'NODETYPE_MAP' },'EOL'=>{'new'=>'NODETYPE_COMPLEX' }},'NODETYPE_FLOWMAP'=>{'DEFAULT'=>{'new'=>'NEWFLOWMAP' },'EOL'=>{'new'=>'NODETYPE_FLOWMAP' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_flow_comma','new'=>'NEWFLOWMAP' },'WS'=>{'new'=>'NODETYPE_FLOWMAP' }},'NODETYPE_FLOWMAPVALUE'=>{'COLON'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR' },'match'=>'cb_flow_colon' },'EOL'=>{'new'=>'NODETYPE_FLOWMAPVALUE' },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOW_COMMA'=>{'match'=>'cb_empty_flowmap_value','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWMAPVALUE' }},'NODETYPE_FLOWSEQ'=>{'DEFAULT'=>{'new'=>'NEWFLOWSEQ' },'EOL'=>{'new'=>'NODETYPE_FLOWSEQ' },'FLOWSEQ_END'=>{'match'=>'cb_end_flowseq','return'=>1 },'WS'=>{'new'=>'NODETYPE_FLOWSEQ' }},'NODETYPE_MAP'=>{'ANCHOR'=>{'WS'=>{'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_tag' }},'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' },'TAG'=>{'WS'=>{'ANCHOR'=>{'WS'=>{'new'=>'RULE_MAPKEY' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_MAPKEY' }},'match'=>'cb_tag' }},'NODETYPE_MAPVALUE_INLINE'=>{'ALIAS'=>{'EOL'=>{},'match'=>'cb_send_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUOTED'=>{'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' }},'NODETYPE_NODE'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqstart' },'DEFAULT'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' }},'NODETYPE_SCALAR_OR_MAP'=>{'ALIAS'=>{'EOL'=>{'match'=>'cb_send_alias_from_stack' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map_alias' }},'match'=>'cb_alias' },'BLOCK_SCALAR'=>{'EOL'=>{},'match'=>'cb_send_block_scalar' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_empty_map' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SCALAR_OR_MAP' },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'EOL'=>{},'match'=>'cb_send_plain_multi' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_questionstart' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_insert_map' }},'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'EOL'=>{},'match'=>'cb_quoted_multiline' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'NODETYPE_SEQ'=>{'DASH'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_seqitem' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'NODETYPE_SEQ' }},'RULE_FLOWSCALAR'=>{'ALIAS'=>{'match'=>'cb_send_alias','return'=>1 },'FLOWMAP_END'=>{'match'=>'cb_end_flowmap_empty','return'=>1 },'FLOWMAP_START'=>{'match'=>'cb_start_flowmap','new'=>'NEWFLOWMAP' },'FLOWSEQ_START'=>{'match'=>'cb_start_flowseq','new'=>'NEWFLOWSEQ' },'FLOW_COMMA'=>{'match'=>'cb_empty_flow_mapkey','return'=>1 },'PLAIN'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'match'=>'cb_start_plain' },'PLAIN_MULTI'=>{'match'=>'cb_send_plain_multi','return'=>1 },'QUOTED'=>{'DEFAULT'=>{'match'=>'cb_send_scalar','return'=>1 },'EOL'=>{'match'=>'cb_send_scalar' },'WS'=>{'match'=>'cb_send_scalar','return'=>1 },'match'=>'cb_take_quoted' },'QUOTED_MULTILINE'=>{'match'=>'cb_quoted_multiline','return'=>1 }},'RULE_FULLFLOWSCALAR'=>{'ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'DEFAULT'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'EOL'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' },'match'=>'cb_tag' }},'RULE_FULLFLOWSCALAR_ANCHOR'=>{'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'TAG'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_tag' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_ANCHOR' }},'RULE_FULLFLOWSCALAR_TAG'=>{'ANCHOR'=>{'EOL'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FLOWSCALAR' },'match'=>'cb_anchor' },'DEFAULT'=>{'new'=>'RULE_FLOWSCALAR' },'WS'=>{'new'=>'RULE_FULLFLOWSCALAR_TAG' }},'RULE_MAPKEY'=>{'ALIAS'=>{'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_send_alias' },'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_empty_mapkey' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_end_doc_start_document' },'EOL'=>{'new'=>'RULE_MAPKEY' },'PLAIN'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' },'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' },'match'=>'cb_send_mapkey' }},'match'=>'cb_mapkey' },'QUESTION'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_question' },'QUOTED'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }},'WS'=>{'COLON'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLMAPVALUE_INLINE' }}},'match'=>'cb_take_quoted_key' }},'STREAM'=>{'DEFAULT'=>{'match'=>'cb_doc_start_implicit','new'=>'FULLNODE' },'DOC_END'=>{'EOL'=>{},'match'=>'cb_end_document_empty' },'DOC_START'=>{'EOL'=>{'new'=>'FULLNODE' },'WS'=>{'new'=>'FULLNODE' },'match'=>'cb_doc_start_explicit' },'EOL'=>{'new'=>'STREAM' },'RESERVED_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_reserved_directive' },'TAG_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_tag_directive' },'YAML_DIRECTIVE'=>{'EOL'=>{'new'=>'DIRECTIVE' },'WS'=>{'new'=>'DIRECTIVE' },'match'=>'cb_set_yaml_version_directive' }}};1;
YAML_PP_GRAMMAR

$fatpacked{"YAML/PP/Highlight.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_HIGHLIGHT';
  use strict;use warnings;package YAML::PP::Highlight;our$VERSION='0.027';our@EXPORT_OK=qw/Dump/;use base 'Exporter';use YAML::PP;use YAML::PP::Parser;use Encode;sub Dump {my (@docs)=@_;require YAML::PP::Schema::Perl;my$yp=YAML::PP->new(schema=>[qw/+ Perl/]);my$yaml=$yp->dump_string(@docs);my ($error,$tokens)=YAML::PP::Parser->yaml_to_tokens(string=>$yaml);my$highlighted=YAML::PP::Highlight->ansicolored($tokens);encode_utf8$highlighted}my%ansicolors=(ANCHOR=>[qw/green/],ALIAS=>[qw/bold green/],TAG=>[qw/bold blue/],INDENT=>[qw/white on_grey3/],COMMENT=>[qw/grey12/],COLON=>[qw/bold magenta/],DASH=>[qw/bold magenta/],QUESTION=>[qw/bold magenta/],YAML_DIRECTIVE=>[qw/cyan/],TAG_DIRECTIVE=>[qw/bold cyan/],SINGLEQUOTE=>[qw/bold green/],SINGLEQUOTED=>[qw/green/],SINGLEQUOTED_LINE=>[qw/green/],DOUBLEQUOTE=>[qw/bold green/],DOUBLEQUOTED=>[qw/green/],DOUBLEQUOTED_LINE=>[qw/green/],LITERAL=>[qw/bold yellow/],FOLDED=>[qw/bold yellow/],DOC_START=>[qw/bold/],DOC_END=>[qw/bold/],BLOCK_SCALAR_CONTENT=>[qw/yellow/],TAB=>[qw/on_blue/],ERROR=>[qw/bold red/],EOL=>[qw/grey12/],TRAILING_SPACE=>[qw/on_grey6/],FLOWSEQ_START=>[qw/bold magenta/],FLOWSEQ_END=>[qw/bold magenta/],FLOWMAP_START=>[qw/bold magenta/],FLOWMAP_END=>[qw/bold magenta/],FLOW_COMMA=>[qw/bold magenta/],PLAINKEY=>[qw/bright_blue/],);sub ansicolored {my ($class,$tokens,%args)=@_;my$expand_tabs=$args{expand_tabs};$expand_tabs=1 unless defined$expand_tabs;require Term::ANSIColor;local$Term::ANSIColor::EACHLINE="\n";my$ansi='';my$highlighted='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$color=$ansicolors{$name };if ($color){$str=Term::ANSIColor::colored($color,$str)}$highlighted .= $str}if ($expand_tabs){$highlighted =~ s/\t/' ' x 8/eg}$ansi .= $highlighted;return$ansi}my%htmlcolors=(ANCHOR=>'anchor',ALIAS=>'alias',SINGLEQUOTE=>'singlequote',DOUBLEQUOTE=>'doublequote',SINGLEQUOTED=>'singlequoted',DOUBLEQUOTED=>'doublequoted',SINGLEQUOTED_LINE=>'singlequoted',DOUBLEQUOTED_LINE=>'doublequoted',INDENT=>'indent',DASH=>'dash',COLON=>'colon',QUESTION=>'question',YAML_DIRECTIVE=>'yaml_directive',TAG_DIRECTIVE=>'tag_directive',TAG=>'tag',COMMENT=>'comment',LITERAL=>'literal',FOLDED=>'folded',DOC_START=>'doc_start',DOC_END=>'doc_end',BLOCK_SCALAR_CONTENT=>'block_scalar_content',TAB=>'tab',ERROR=>'error',EOL=>'eol',TRAILING_SPACE=>'trailing_space',FLOWSEQ_START=>'flowseq_start',FLOWSEQ_END=>'flowseq_end',FLOWMAP_START=>'flowmap_start',FLOWMAP_END=>'flowmap_end',FLOW_COMMA=>'flow_comma',PLAINKEY=>'plainkey',);sub htmlcolored {require HTML::Entities;my ($class,$tokens)=@_;my$html='';my@list=$class->transform($tokens);for my$token (@list){my$name=$token->{name};my$str=$token->{value};my$colorclass=$htmlcolors{$name }|| 'default';$str=HTML::Entities::encode_entities($str);$html .= qq{<span class="$colorclass">$str</span>}}return$html}sub transform {my ($class,$tokens)=@_;my@list;for my$token (@$tokens){my@values;my$value=$token->{value};my$subtokens=$token->{subtokens};if ($subtokens){@values=@$subtokens}else {@values=$token}for my$token (@values){my$value=defined$token->{orig}? $token->{orig}: $token->{value};push@list,map {$_ =~ tr/\t/\t/ ? {name=>'TAB',value=>$_ }: {name=>$token->{name},value=>$_ }}split m/(\t+)/,$value}}for my$i (0 .. $#list){my$token=$list[$i ];my$name=$token->{name};my$str=$token->{value};my$trailing_space=0;if ($token->{name}eq 'EOL'){if ($str =~ m/ +([\r\n]|\z)/){$token->{name}="TRAILING_SPACE"}}elsif ($i < $#list){if ($name eq 'PLAIN'){for my$n ($i+1 .. $#list){my$next=$list[$n ];last if$next->{name}eq 'EOL';next if$next->{name}=~ m/^(WS|SPACE)$/;if ($next->{name}eq 'COLON'){$token->{name}='PLAINKEY'}}}my$next=$list[$i + 1];if ($next->{name}eq 'EOL'){if ($str =~ m/ \z/ and $name =~ m/^(BLOCK_SCALAR_CONTENT|WS)$/){$token->{name}="TRAILING_SPACE"}}}}return@list}1;
YAML_PP_HIGHLIGHT

$fatpacked{"YAML/PP/Lexer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LEXER';
  use strict;use warnings;package YAML::PP::Lexer;our$VERSION='0.027';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Grammar qw/$GRAMMAR/;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$self=bless {reader=>$args{reader},},$class;$self->init;return$self}sub init {my ($self)=@_;$self->{next_tokens}=[];$self->{next_line}=undef;$self->{line}=0;$self->{offset}=0;$self->{flowcontext}=0}sub next_line {return $_[0]->{next_line}}sub set_next_line {$_[0]->{next_line}=$_[1]}sub reader {return $_[0]->{reader}}sub set_reader {$_[0]->{reader}=$_[1]}sub next_tokens {return $_[0]->{next_tokens}}sub line {return $_[0]->{line}}sub set_line {$_[0]->{line}=$_[1]}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub inc_line {return $_[0]->{line}++}sub context {return $_[0]->{context}}sub set_context {$_[0]->{context}=$_[1]}sub flowcontext {return $_[0]->{flowcontext}}sub set_flowcontext {$_[0]->{flowcontext}=$_[1]}my$RE_WS='[\t ]';my$RE_LB='[\r\n]';my$RE_DOC_END=qr/\A(\.\.\.)(?=$RE_WS|$)/m;my$RE_DOC_START=qr/\A(---)(?=$RE_WS|$)/m;my$RE_EOL=qr/\A($RE_WS+#.*|$RE_WS+)\z/;my$RE_NS_WORD_CHAR='[0-9A-Za-z-]';my$RE_URI_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$,_.!*'\(\)\[\]-]} .')';my$RE_NS_TAG_CHAR='(?:' .'%[0-9a-fA-F]{2}' .'|'.q{[0-9A-Za-z#;/?:@&=+$_.*'\(\)-]} .')';my$RE_ANCHOR_CAR='[\x21-\x2B\x2D-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START='[\x21\x22\x24-\x39\x3B-\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END='[\x21-\x39\x3B-\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_START_FLOW='[\x21\x22\x24-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_END_FLOW='[\x21-\x2B\x2D-\x39\x3B-\x5A\x5C\x5E-\x7A\x7C\x7E\x85\xA0-\x{D7FF}\x{E000}-\x{FEFE}\x{FF00}-\x{FFFD}\x{10000}-\x{10FFFF}]';my$RE_PLAIN_FIRST_FLOW='[\x24\x28-\x29\x2B\x2E-\x39\x3B-\x3D\x41-\x5A\x5C\x5E-\x5F\x61-\x7A\x7C\x7E\xA0-\xFF\x{100}-\x{10FFFF}]';my$RE_PLAIN_WORD="(?::+$RE_PLAIN_END|$RE_PLAIN_START)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_FIRST_WORD="(?:[:?-]+$RE_PLAIN_END|$RE_PLAIN_FIRST)(?::+$RE_PLAIN_END|$RE_PLAIN_END)*";my$RE_PLAIN_WORDS="(?:$RE_PLAIN_FIRST_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORDS2="(?:$RE_PLAIN_WORD(?:$RE_WS+$RE_PLAIN_WORD)*)";my$RE_PLAIN_WORD_FLOW="(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_START_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_FIRST_WORD_FLOW="(?:[:?-]+$RE_PLAIN_END_FLOW|$RE_PLAIN_FIRST_FLOW)(?::+$RE_PLAIN_END_FLOW|$RE_PLAIN_END_FLOW)*";my$RE_PLAIN_WORDS_FLOW="(?:$RE_PLAIN_FIRST_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_PLAIN_WORDS_FLOW2="(?:$RE_PLAIN_WORD_FLOW(?:$RE_WS+$RE_PLAIN_WORD_FLOW)*)";my$RE_TAG="!(?:$RE_NS_WORD_CHAR*!$RE_NS_TAG_CHAR+|$RE_NS_TAG_CHAR+|<$RE_URI_CHAR+>|)";my$RE_SEQSTART=qr/\A(-)(?=$RE_WS|$)/m;my$RE_COMPLEX=qr/(\?)(?=$RE_WS|$)/m;my$RE_COMPLEXCOLON=qr/\A(:)(?=$RE_WS|$)/m;my$RE_ANCHOR="&$RE_ANCHOR_CAR+";my$RE_ALIAS="\\*$RE_ANCHOR_CAR+";my%REGEXES=(ANCHOR=>qr{($RE_ANCHOR)},TAG=>qr{($RE_TAG)},ALIAS=>qr{($RE_ALIAS)},SINGLEQUOTED=>qr{(?:''|[^'\r\n]+)*},);sub fetch_next_line {my ($self)=@_;my$next_line=$self->next_line;if (defined$next_line){return$next_line}my$line=$self->reader->readline;unless (defined$line){$self->set_next_line(undef);return}$self->inc_line;$line =~ m/\A( *)([^\r\n]*)([\r\n]|\z)/ or die "Unexpected";$next_line=[$1,$2,$3 ];$self->set_next_line($next_line);if ($line =~ tr/\x00-\x08\x0b-\x0c\x0e-\x1f//){$self->exception("Control characters are not allowed")}return$next_line}my%TOKEN_NAMES=('"'=>'DOUBLEQUOTE',"'"=>'SINGLEQUOTE','|'=>'LITERAL','>'=>'FOLDED','!'=>'TAG','*'=>'ALIAS','&'=>'ANCHOR',':'=>'COLON','-'=>'DASH','?'=>'QUESTION','['=>'FLOWSEQ_START',']'=>'FLOWSEQ_END','{'=>'FLOWMAP_START','}'=>'FLOWMAP_END',','=>'FLOW_COMMA','---'=>'DOC_START','...'=>'DOC_END',);sub fetch_next_tokens {my ($self)=@_;my$next=$self->next_tokens;return$next if @$next;my$next_line=$self->fetch_next_line;if (not $next_line){return []}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];if (not length $$yaml){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (substr($$yaml,0,1)eq '#'){$self->push_tokens([EOL=>join('',@$next_line),$self->line ]);$self->set_next_line(undef);return$next}if (not $spaces and substr($$yaml,0,1)eq "%"){$self->_fetch_next_tokens_directive($yaml,$next_line->[2]);$self->set_context(0);$self->set_next_line(undef);return$next}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){$self->push_tokens([$TOKEN_NAMES{$1 }=>$1,$self->line ])}else {$self->push_tokens([SPACE=>$spaces,$self->line ])}my$partial=$self->_fetch_next_tokens($next_line);unless ($partial){$self->set_next_line(undef)}return$next}my%ANCHOR_ALIAS_TAG=('&'=>1,'*'=>1,'!'=>1);my%BLOCK_SCALAR=('|'=>1,'>'=>1);my%COLON_DASH_QUESTION=(':'=>1,'-'=>1,'?'=>1);my%QUOTED=('"'=>1,"'"=>1);my%FLOW=('{'=>1,'['=>1,'}'=>1,']'=>1,','=>1);my%CONTEXT=('"'=>1,"'"=>1,'>'=>1,'|'=>1);my$RE_ESCAPES=qr{(?:
      \\([ \\\/_0abefnrtvLNP"]) | \\x([0-9a-fA-F]{2})
      | \\u([A-Fa-f0-9]{4}) | \\U([A-Fa-f0-9]{4,8})
  )}x;my%CONTROL=('\\'=>'\\','/'=>'/',n=>"\n",t=>"\t",r=>"\r",b=>"\b",'a'=>"\a",'b'=>"\b",'e'=>"\e",'f'=>"\f",'v'=>"\x0b",'P'=>"\x{2029}",L=>"\x{2028}",'N'=>"\x85",'0'=>"\0",'_'=>"\xa0",' '=>' ',q/"/=>q/"/,);sub _fetch_next_tokens {TRACE and warn __PACKAGE__.':'.__LINE__.": _fetch_next_tokens\n";my ($self,$next_line)=@_;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;while (1){unless (length $$yaml){push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}my$first=substr($$yaml,0,1);my$plain=0;if ($self->context){if ($$yaml =~ s/\A($RE_WS*)://){push@tokens,(WS=>$1,$self->line)if $1;push@tokens,(COLON=>':',$self->line);$self->set_context(0);next}if ($$yaml =~ s/\A($RE_WS*(?: #.*))\z//){push@tokens,(EOL=>$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}$self->set_context(0)}if ($CONTEXT{$first }){push@tokens,(CONTEXT=>$first,$self->line);$self->push_tokens(\@tokens);return 1}elsif ($COLON_DASH_QUESTION{$first }){my$token_name=$TOKEN_NAMES{$first };if ($$yaml =~ s/\A\Q$first\E(?:($RE_WS+)|\z)//){my$token_name=$TOKEN_NAMES{$first };push@tokens,($token_name=>$first,$self->line);if (not defined $1){push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}my$ws=$1;if ($$yaml =~ s/\A(#.*|)\z//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line);next}elsif ($self->flowcontext and $$yaml =~ s/\A:(?=[,\{\}\[\]])//){push@tokens,($token_name=>$first,$self->line);next}$plain=1}elsif ($ANCHOR_ALIAS_TAG{$first }){my$token_name=$TOKEN_NAMES{$first };my$REGEX=$REGEXES{$token_name };if ($$yaml =~ s/\A$REGEX//){push@tokens,($token_name=>$1,$self->line)}else {push@tokens,("Invalid $token_name"=>$$yaml,$self->line);$self->push_tokens(\@tokens);return}}elsif ($first eq ' ' or $first eq "\t"){if ($$yaml =~ s/\A($RE_WS+)//){my$ws=$1;if ($$yaml =~ s/\A((?:#.*)?\z)//){push@tokens,(EOL=>$ws .$1 .$eol,$self->line);$self->push_tokens(\@tokens);return}push@tokens,(WS=>$ws,$self->line)}}elsif ($FLOW{$first }){push@tokens,($TOKEN_NAMES{$first }=>$first,$self->line);substr($$yaml,0,1,'');my$flowcontext=$self->flowcontext;if ($first eq '{' or $first eq '['){$self->set_flowcontext(++$flowcontext)}elsif ($first eq '}' or $first eq ']'){$self->set_flowcontext(--$flowcontext)}}else {$plain=1}if ($plain){push@tokens,(CONTEXT=>'',$self->line);$self->push_tokens(\@tokens);return 1}}return}sub fetch_plain {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my$REGEX=$RE_PLAIN_WORDS;if ($self->flowcontext){$REGEX=$RE_PLAIN_WORDS_FLOW}my@tokens;unless ($$yaml =~ s/\A($REGEX)//){$self->push_tokens(\@tokens);$self->exception("Invalid plain scalar")}my$plain=$1;push@tokens,(PLAIN=>$plain,$self->line);if ($$yaml =~ s/\A(?:($RE_WS+#.*)|($RE_WS*))\z//){if (defined $1){push@tokens,(EOL=>$1 .$eol,$self->line);$self->push_tokens(\@tokens);$self->set_next_line(undef);return}else {push@tokens,(EOL=>$2.$eol,$self->line);$self->set_next_line(undef)}}else {$self->push_tokens(\@tokens);my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return}my$RE2=$RE_PLAIN_WORDS2;if ($self->flowcontext){$RE2=$RE_PLAIN_WORDS_FLOW2}my$fetch_next=0;my@lines=($plain);my@next;LOOP: while (1){$next_line=$self->fetch_next_line;if (not $next_line){last LOOP}my$spaces=$next_line->[0];my$yaml=\$next_line->[1];my$eol=$next_line->[2];if (not length $$yaml){push@tokens,(EOL=>$spaces .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if (not $spaces and $$yaml =~ s/\A(---|\.\.\.)(?=$RE_WS|\z)//){push@next,$TOKEN_NAMES{$1 }=>$1,$self->line;$fetch_next=1;last LOOP}if ((length$spaces)< $indent){last LOOP}my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,(EOL=>$spaces .$ws .$eol,$self->line);$self->set_next_line(undef);push@lines,'';next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,(EOL=>$spaces .$ws .$1 .$eol,$self->line);$self->set_next_line(undef);last LOOP}if ($$yaml =~ s/\A($RE2)//){push@tokens,INDENT=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;push@tokens,PLAIN=>$1,$self->line;push@lines,$1;my$ws='';if ($$yaml =~ s/\A($RE_WS+)//){$ws=$1}if (not length $$yaml){push@tokens,EOL=>$ws .$eol,$self->line;$self->set_next_line(undef);next LOOP}if ($$yaml =~ s/\A(#.*)\z//){push@tokens,EOL=>$ws .$1 .$eol,$self->line;$self->set_next_line(undef);last LOOP}else {push@tokens,WS=>$ws,$self->line if$ws;$fetch_next=1}}else {push@tokens,SPACE=>$spaces,$self->line;push@tokens,WS=>$ws,$self->line;if ($self->flowcontext){$fetch_next=1}else {push@tokens,ERROR=>$$yaml,$self->line}}last LOOP}while (@lines > 1 and $lines[-1]eq ''){pop@lines}if (@lines > 1){my$value=YAML::PP::Render->render_multi_val(\@lines);my@eol;if ($tokens[-3]eq 'EOL'){@eol=splice@tokens,-3}$self->push_subtokens({name=>'PLAIN_MULTI',value=>$value },\@tokens);$self->push_tokens([@eol,@next ])}else {$self->push_tokens([@tokens,@next ])}@tokens=();if ($fetch_next){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}}return}sub fetch_block {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$eol=$next_line->[2];my@tokens;my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context\E// or die "Unexpected";push@tokens,($token_name=>$context,$self->line);my$current_indent=$indent;my$started=0;my$set_indent=0;my$chomp='';if ($$yaml =~ s/\A([1-9]\d*)([+-]?)//){push@tokens,(BLOCK_SCALAR_INDENT=>$1,$self->line);$set_indent=$1;$chomp=$2 if $2;push@tokens,(BLOCK_SCALAR_CHOMP=>$2,$self->line)if $2}elsif ($$yaml =~ s/\A([+-])([1-9]\d*)?//){push@tokens,(BLOCK_SCALAR_CHOMP=>$1,$self->line);$chomp=$1;push@tokens,(BLOCK_SCALAR_INDENT=>$2,$self->line)if $2;$set_indent=$2 if $2}if ($set_indent){$started=1;$current_indent=$set_indent}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}elsif ($$yaml =~ s/\A($RE_WS*(?:$RE_WS#.*|))\z//){push@tokens,(EOL=>$1 .$eol,$self->line)}else {$self->push_tokens(\@tokens);$self->exception("Invalid block scalar")}my@lines;while (1){$self->set_next_line(undef);$next_line=$self->fetch_next_line;if (not $next_line){last}my$spaces=$next_line->[0];my$content=$next_line->[1];my$eol=$next_line->[2];if (not $spaces and $content =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){last}if ((length$spaces)< $current_indent){if (length$content){last}else {push@lines,'';push@tokens,(EOL=>$spaces .$eol,$self->line);next}}if ((length$spaces)> $current_indent){if ($started){($spaces,my$more_spaces)=unpack "a${current_indent}a*",$spaces;$content=$more_spaces .$content}}unless (length$content){push@lines,'';push@tokens,(INDENT=>$spaces,$self->line,EOL=>$eol,$self->line);unless ($started){$current_indent=length$spaces}next}unless ($started){$started=1;$current_indent=length$spaces}push@lines,$content;push@tokens,(INDENT=>$spaces,$self->line,BLOCK_SCALAR_CONTENT=>$content,$self->line,EOL=>$eol,$self->line,)}my$value=YAML::PP::Render->render_block_scalar($context,$chomp,\@lines);my@eol=splice@tokens,-3;$self->push_subtokens({name=>'BLOCK_SCALAR',value=>$value },\@tokens);$self->push_tokens([@eol ]);return 0}sub fetch_quoted {my ($self,$indent,$context)=@_;my$next_line=$self->next_line;my$yaml=\$next_line->[1];my$spaces=$next_line->[0];my$token_name=$TOKEN_NAMES{$context };$$yaml =~ s/\A\Q$context// or die "Unexpected";;my@tokens=($token_name=>$context,$self->line);my$start=1;my@values;while (1){unless ($start){$next_line=$self->fetch_next_line or do {for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Missing closing quote <$context> at EOF")};$start=0;$spaces=$next_line->[0];$yaml=\$next_line->[1];if (not length $$yaml){push@tokens,(EOL=>$spaces .$next_line->[2],$self->line);$self->set_next_line(undef);push@values,{value=>'',orig=>'' };next}elsif (not $spaces and $$yaml =~ m/\A(---|\.\.\.)(?=$RE_WS|\z)/){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Missing closing quote <$context> or invalid document marker")}elsif ((length$spaces)< $indent){for (my$i=0;$i < @tokens;$i+= 3){my$token=$tokens[$i + 1 ];if (ref$token){$tokens[$i + 1 ]=$token->{orig}}}$self->push_tokens(\@tokens);$self->exception("Wrong indendation or missing closing quote <$context>")}if ($$yaml =~ s/\A($RE_WS+)//){$spaces .= $1}push@tokens,(WS=>$spaces,$self->line)}my$v=$self->_read_quoted_tokens($start,$context,$yaml,\@tokens);push@values,$v;if ($tokens[-3]eq $token_name){if ($start){$self->push_subtokens({name=>'QUOTED',value=>$v->{value}},\@tokens)}else {my$value=YAML::PP::Render->render_quoted($context,\@values);$self->push_subtokens({name=>'QUOTED_MULTILINE',value=>$value },\@tokens)}$self->set_context(1)if$self->flowcontext;if (length $$yaml){my$partial=$self->_fetch_next_tokens($next_line);if (not $partial){$self->set_next_line(undef)}return 0}else {@tokens=();push@tokens,(EOL=>$next_line->[2],$self->line);$self->push_tokens(\@tokens);$self->set_next_line(undef);return}}$tokens[-2].= $next_line->[2];$self->set_next_line(undef);$start=0}}sub _read_quoted_tokens {my ($self,$start,$first,$yaml,$tokens)=@_;my$quoted='';my$decoded='';my$token_name=$TOKEN_NAMES{$first };if ($first eq "'"){my$regex=$REGEXES{SINGLEQUOTED};if ($$yaml =~ s/\A($regex)//){$quoted .= $1;$decoded .= $1;$decoded =~ s/''/'/g}}else {($quoted,$decoded)=$self->_read_doublequoted($yaml)}my$eol='';unless (length $$yaml){if ($quoted =~ s/($RE_WS+)\z//){$eol=$1;$decoded =~ s/($eol)\z//}}my$value={value=>$decoded,orig=>$quoted };if ($$yaml =~ s/\A$first//){if ($start){push @$tokens,($token_name .'D'=>$value,$self->line)}else {push @$tokens,($token_name .'D_LINE'=>$value,$self->line)}push @$tokens,($token_name=>$first,$self->line);return$value}if (length $$yaml){push @$tokens,($token_name .'D'=>$value->{orig},$self->line);$self->push_tokens($tokens);$self->exception("Invalid quoted <$first> string")}push @$tokens,($token_name .'D_LINE'=>$value,$self->line);push @$tokens,(EOL=>$eol,$self->line);return$value}sub _read_doublequoted {my ($self,$yaml)=@_;my$quoted='';my$decoded='';while (1){my$last=1;if ($$yaml =~ s/\A([^"\\]+)//){$quoted .= $1;$decoded .= $1;$last=0}if ($$yaml =~ s/\A($RE_ESCAPES)//){$quoted .= $1;my$dec=defined $2 ? $CONTROL{$2 }: defined $3 ? chr hex $3 : defined $4 ? chr hex $4 : chr hex $5;$decoded .= $dec;$last=0}if ($$yaml =~ s/\A(\\)\z//){$quoted .= $1;$decoded .= $1;last}last if$last}return ($quoted,$decoded)}sub _fetch_next_tokens_directive {my ($self,$yaml,$eol)=@_;my@tokens;if ($$yaml =~ s/\A(\s*%YAML)//){my$dir=$1;if ($$yaml =~ s/\A( )//){$dir .= $1;if ($$yaml =~ s/\A(1\.[12]$RE_WS*)//){$dir .= $1;push@tokens,(YAML_DIRECTIVE=>$dir,$self->line)}else {$$yaml =~ s/\A(.*)//;$dir .= $1;my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($warn eq 'warn'){warn "Found reserved directive '$dir'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$dir'"}push@tokens,(RESERVED_DIRECTIVE=>"$dir",$self->line)}}else {$$yaml =~ s/\A(.*)//;$dir .= $1;push@tokens,('Invalid directive'=>$dir,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}}elsif ($$yaml =~ s/\A(\s*%TAG +(!$RE_NS_WORD_CHAR*!|!) +(tag:\S+|!$RE_URI_CHAR+)$RE_WS*)//){push@tokens,(TAG_DIRECTIVE=>$1,$self->line);my$tag_alias=$2;my$tag_url=$3}elsif ($$yaml =~ s/\A(\s*\A%(?:\w+).*)//){push@tokens,(RESERVED_DIRECTIVE=>$1,$self->line);my$warn=$ENV{YAML_PP_RESERVED_DIRECTIVE}|| 'warn';if ($warn eq 'warn'){warn "Found reserved directive '$1'"}elsif ($warn eq 'fatal'){die "Found reserved directive '$1'"}}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line);$self->push_tokens(\@tokens);return}if (not length $$yaml){push@tokens,(EOL=>$eol,$self->line)}else {push@tokens,('Invalid directive'=>$$yaml,$self->line);push@tokens,(EOL=>$eol,$self->line)}$self->push_tokens(\@tokens);return}sub push_tokens {my ($self,$new_tokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;for (my$i=0;$i < @$new_tokens;$i += 3){my$value=$new_tokens->[$i + 1 ];my$name=$new_tokens->[$i ];my$line=$new_tokens->[$i + 2 ];my$push={name=>$name,line=>$line,column=>$column,value=>$value,};$column += length$value unless$name eq 'CONTEXT';push @$next,$push;if ($name eq 'EOL'){$column=0}}$self->set_offset($column);return$next}sub push_subtokens {my ($self,$token,$subtokens)=@_;my$next=$self->next_tokens;my$line=$self->line;my$column=$self->offset;$token->{column}=$column;$token->{subtokens}=\my@sub;for (my$i=0;$i < @$subtokens;$i+=3){my$name=$subtokens->[$i ];my$value=$subtokens->[$i + 1 ];my$line=$subtokens->[$i + 2 ];my$push={name=>$subtokens->[$i ],line=>$line,column=>$column,};if (ref$value eq 'HASH'){%$push=(%$push,%$value);$column += length$value->{orig}}else {$push->{value}=$value;$column += length$value}if ($push->{name}eq 'EOL'){$column=0}push@sub,$push}$token->{line}=$sub[0]->{line};push @$next,$token;$self->set_offset($column);return$next}sub exception {my ($self,$msg)=@_;my$next=$self->next_tokens;$next=[];my$line=@$next ? $next->[0]->{line}: $self->line;my@caller=caller(0);my$yaml='';if (my$nl=$self->next_line){$yaml=join '',@$nl;$yaml=$nl->[1]}my$e=YAML::PP::Exception->new(line=>$line,column=>$self->offset + 1,msg=>$msg,next=>$next,where=>$caller[1].' line ' .$caller[2],yaml=>$yaml,);croak$e}1;
YAML_PP_LEXER

$fatpacked{"YAML/PP/Loader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_LOADER';
  use strict;use warnings;package YAML::PP::Loader;our$VERSION='0.027';use YAML::PP::Parser;use YAML::PP::Constructor;use YAML::PP::Reader;sub new {my ($class,%args)=@_;my$cyclic_refs=delete$args{cyclic_refs}|| 'allow';my$default_yaml_version=delete$args{default_yaml_version}|| '1.2';my$preserve=delete$args{preserve};my$duplicate_keys=delete$args{duplicate_keys};my$schemas=delete$args{schemas};$schemas ||= {'1.2'=>YAML::PP->default_schema(boolean=>'perl',)};my$constructor=delete$args{constructor}|| YAML::PP::Constructor->new(schemas=>$schemas,cyclic_refs=>$cyclic_refs,default_yaml_version=>$default_yaml_version,preserve=>$preserve,duplicate_keys=>$duplicate_keys,);my$parser=delete$args{parser};unless ($parser){$parser=YAML::PP::Parser->new(default_yaml_version=>$default_yaml_version,)}unless ($parser->receiver){$parser->set_receiver($constructor)}if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$self=bless {parser=>$parser,constructor=>$constructor,},$class;return$self}sub clone {my ($self)=@_;my$clone={parser=>$self->parser->clone,constructor=>$self->constructor->clone,};bless$clone,ref$self;$clone->parser->set_receiver($clone->constructor);return$clone}sub parser {return $_[0]->{parser}}sub constructor {return $_[0]->{constructor}}sub filename {my ($self)=@_;my$reader=$self->parser->reader;if ($reader->isa('YAML::PP::Reader::File')){return$reader->input}die "Reader is not a YAML::PP::Reader::File"}sub load_string {my ($self,$yaml)=@_;$self->parser->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->load()}sub load_file {my ($self,$file)=@_;$self->parser->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->load()}sub load {my ($self)=@_;my$parser=$self->parser;my$constructor=$self->constructor;$constructor->init;$parser->parse();my$docs=$constructor->docs;return wantarray ? @$docs : $docs->[0]}1;
YAML_PP_LOADER

$fatpacked{"YAML/PP/Parser.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PARSER';
  use strict;use warnings;package YAML::PP::Parser;our$VERSION='0.027';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;use constant DEBUG=>($ENV{YAML_PP_DEBUG}|| $ENV{YAML_PP_TRACE})? 1 : 0;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE/;use YAML::PP::Render;use YAML::PP::Lexer;use YAML::PP::Grammar qw/$GRAMMAR/;use YAML::PP::Exception;use YAML::PP::Reader;use Carp qw/croak/;sub new {my ($class,%args)=@_;my$reader=delete$args{reader}|| YAML::PP::Reader->new;my$default_yaml_version=delete$args{default_yaml_version};my$self=bless {default_yaml_version=>$default_yaml_version || '1.2',lexer=>YAML::PP::Lexer->new(reader=>$reader,),},$class;my$receiver=delete$args{receiver};if ($receiver){$self->set_receiver($receiver)}return$self}sub clone {my ($self)=@_;my$clone={default_yaml_version=>$self->default_yaml_version,lexer=>YAML::PP::Lexer->new(),};return bless$clone,ref$self}sub receiver {return $_[0]->{receiver}}sub set_receiver {my ($self,$receiver)=@_;my$callback;if (ref$receiver eq 'CODE'){$callback=$receiver}else {$callback=sub {my ($self,$event,$info)=@_;return$receiver->$event($info)}}$self->{callback}=$callback;$self->{receiver}=$receiver}sub reader {return $_[0]->lexer->{reader}}sub set_reader {my ($self,$reader)=@_;$self->lexer->set_reader($reader)}sub lexer {return $_[0]->{lexer}}sub callback {return $_[0]->{callback}}sub set_callback {$_[0]->{callback}=$_[1]}sub level {return $#{$_[0]->{offset}}}sub offset {return $_[0]->{offset}}sub set_offset {$_[0]->{offset}=$_[1]}sub events {return $_[0]->{events}}sub set_events {$_[0]->{events}=$_[1]}sub new_node {return $_[0]->{new_node}}sub set_new_node {$_[0]->{new_node}=$_[1]}sub tagmap {return $_[0]->{tagmap}}sub set_tagmap {$_[0]->{tagmap}=$_[1]}sub tokens {return $_[0]->{tokens}}sub set_tokens {$_[0]->{tokens}=$_[1]}sub event_stack {return $_[0]->{event_stack}}sub set_event_stack {$_[0]->{event_stack}=$_[1]}sub default_yaml_version {return $_[0]->{default_yaml_version}}sub yaml_version {return $_[0]->{yaml_version}}sub set_yaml_version {$_[0]->{yaml_version}=$_[1]}sub yaml_version_directive {return $_[0]->{yaml_version_directive}}sub set_yaml_version_directive {$_[0]->{yaml_version_directive}=$_[1]}sub rule {return $_[0]->{rule}}sub set_rule {my ($self,$name)=@_;no warnings 'uninitialized';DEBUG and $self->info("set_rule($name)");$self->{rule}=$name}sub init {my ($self)=@_;$self->set_offset([]);$self->set_events([]);$self->set_new_node(0);$self->set_tagmap({'!!'=>"tag:yaml.org,2002:",});$self->set_tokens([]);$self->set_rule(undef);$self->set_event_stack([]);$self->set_yaml_version($self->default_yaml_version);$self->set_yaml_version_directive(undef);$self->lexer->init}sub parse_string {my ($self,$yaml)=@_;$self->set_reader(YAML::PP::Reader->new(input=>$yaml));$self->parse()}sub parse_file {my ($self,$file)=@_;$self->set_reader(YAML::PP::Reader::File->new(input=>$file));$self->parse()}my%nodetypes=(MAPVALUE=>'NODETYPE_COMPLEX',MAP=>'NODETYPE_MAP',SEQ=>'NODETYPE_SEQ',SEQ0=>'NODETYPE_SEQ',FLOWMAP=>'NODETYPE_FLOWMAP',FLOWMAPVALUE=>'NODETYPE_FLOWMAPVALUE',FLOWSEQ=>'NODETYPE_FLOWSEQ',FLOWSEQ_NEXT=>'FLOWSEQ_NEXT',DOC=>'FULLNODE',DOC_END=>'DOCUMENT_END',STR=>'STREAM',);sub parse {my ($self)=@_;TRACE and warn "=== parse()\n";TRACE and $self->debug_yaml;$self->init;$self->lexer->init;eval {$self->start_stream;$self->set_rule('STREAM');$self->parse_tokens();$self->end_stream};if (my$error=$@){if (ref$error){croak "$error\n "}croak$error}DEBUG and $self->highlight_yaml;TRACE and $self->debug_tokens}sub lex_next_tokens {my ($self)=@_;DEBUG and $self->info("----------------> lex_next_tokens");TRACE and $self->debug_events;my$indent=$self->offset->[-1];my$event_types=$self->events;my$next_tokens=$self->lexer->fetch_next_tokens($indent);return unless @$next_tokens;my$next=$next_tokens->[0];return 1 if ($next->{name}ne 'SPACE');my$flow=$event_types->[-1]=~ m/^FLOW/;my$space=length$next->{value};my$tokens=$self->tokens;if (not $space){shift @$next_tokens}else {push @$tokens,shift @$next_tokens}if ($flow){if ($space >= $indent){return 1}$self->exception("Bad indendation in " .$self->events->[-1])}$next=$next_tokens->[0];if ($space > $indent){return 1 if$indent < 0;unless ($self->new_node){$self->exception("Bad indendation in " .$self->events->[-1])}return 1}if ($self->new_node){if ($space < $indent){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$self->remove_nodes($space)}else {my$exp=$self->events->[-1];my$seq_start=$next->{name}eq 'DASH';if ($seq_start and ($exp eq 'MAPVALUE' or $exp eq 'MAP')){}else {$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}}}else {if ($space < $indent){$self->remove_nodes($space)}}my$exp=$self->events->[-1];if ($exp eq 'SEQ0' and $next->{name}ne 'DASH'){TRACE and $self->info("In unindented sequence");$self->end_sequence;$exp=$self->events->[-1]}if ($self->offset->[-1]!=$space){$self->exception("Expected " .$self->events->[-1])}return 1}my%next_event=(MAP=>'MAPVALUE',MAPVALUE=>'MAP',SEQ=>'SEQ',SEQ0=>'SEQ0',DOC=>'DOC_END',STR=>'STR',FLOWSEQ=>'FLOWSEQ_NEXT',FLOWSEQ_NEXT=>'FLOWSEQ',FLOWMAP=>'FLOWMAPVALUE',FLOWMAPVALUE=>'FLOWMAP',);my%event_to_method=(MAP=>'mapping',FLOWMAP=>'mapping',SEQ=>'sequence',SEQ0=>'sequence',FLOWSEQ=>'sequence',DOC=>'document',STR=>'stream',VAL=>'scalar',ALI=>'alias',MAPVALUE=>'mapping',);my%fetch_method=('"'=>'fetch_quoted',"'"=>'fetch_quoted','|'=>'fetch_block','>'=>'fetch_block',''=>'fetch_plain',);sub parse_tokens {my ($self)=@_;my$event_types=$self->events;my$offsets=$self->offset;my$tokens=$self->tokens;my$next_tokens=$self->lexer->next_tokens;unless ($self->lex_next_tokens){$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){my$new_rule=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($new_rule)}}my$rule_name=$self->rule;DEBUG and $self->info("----------------> parse_tokens($rule_name)");my$rule=$GRAMMAR->{$rule_name }or die "Could not find rule $rule_name";TRACE and $self->debug_rules($rule);TRACE and $self->debug_yaml;DEBUG and $self->debug_next_line;RULE: while ($rule_name){DEBUG and $self->info("RULE: $rule_name");TRACE and $self->debug_tokens($next_tokens);unless (@$next_tokens){$self->exception("No more tokens")}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$next_tokens->[0]],['next_token']);my$got=$next_tokens->[0]->{name};if ($got eq 'CONTEXT'){my$context=shift @$next_tokens;my$indent=$offsets->[-1];$indent++ unless$self->lexer->flowcontext;my$method=$fetch_method{$context->{value}};my$partial=$self->lexer->$method($indent,$context->{value});next RULE}my$def=$rule->{$got };if ($def){push @$tokens,shift @$next_tokens}elsif ($def=$rule->{DEFAULT}){$got='DEFAULT'}else {$self->expected(expected=>[keys %$rule],got=>$next_tokens->[0],)}DEBUG and $self->got("---got $got");if (my$sub=$def->{match}){DEBUG and $self->info("CALLBACK $sub");$self->$sub(@$tokens ? $tokens->[-1]: ())}my$eol=$got eq 'EOL';my$new=$def->{new};if ($new){DEBUG and $self->got("NEW: $new");$rule_name=$new;$self->set_rule($rule_name)}elsif ($eol){}elsif ($def->{return}){$rule_name=$nodetypes{$event_types->[-1]}or die "Unexpected event type $event_types->[-1]";$self->set_rule($rule_name)}else {$rule_name .= " - $got";$rule=$def;next RULE}if ($eol){unless ($self->lex_next_tokens){$self->end_document(1);return 0}unless ($self->new_node){if ($self->level > 0){$rule_name=$nodetypes{$event_types->[-1]}or die "Did not find '$event_types->[-1]'";$self->set_rule($rule_name)}}$rule_name=$self->rule}$rule=$GRAMMAR->{$rule_name }or die "Unexpected rule $rule_name"}die "Unexpected"}sub end_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]}}sub remove_nodes {my ($self,$space)=@_;my$offset=$self->offset;my$event_types=$self->events;my$exp=$event_types->[-1];while (@$offset){if ($offset->[-1 ]<= $space){last}if ($exp eq 'MAPVALUE'){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' });$exp='MAP'}my$info={name=>$exp };$info->{name}=$event_to_method{$exp }.'_end_event';pop @{$event_types};pop @{$offset};$self->callback->($self,$info->{name}=>$info);$event_types->[-1]=$next_event{$event_types->[-1]};$exp=$event_types->[-1]}return$exp}sub start_stream {my ($self)=@_;push @{$self->events},'STR';push @{$self->offset},-1;$self->callback->($self,'stream_start_event',{name=>'stream_start_event',})}sub start_document {my ($self,$implicit)=@_;push @{$self->events},'DOC';push @{$self->offset},-1;my$directive=$self->yaml_version_directive;my%directive;if ($directive){my ($major,$minor)=split m/\./,$self->yaml_version;%directive=(version_directive=>{major=>$major,minor=>$minor })}$self->callback->($self,'document_start_event',{name=>'document_start_event',implicit=>$implicit,%directive,});$self->set_yaml_version_directive(undef);$self->set_rule('FULLNODE');$self->set_new_node(1)}sub start_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;if ($offsets->[-1]==$offset){push @{$self->events},'SEQ0'}else {push @{$self->events},'SEQ'}push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_sequence {my ($self,$offset)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},'FLOWSEQ';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={style=>YAML_FLOW_SEQUENCE_STYLE,name=>'sequence_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'sequence_start_event',$info)}sub start_flow_mapping {my ($self,$offset)=@_;my$offsets=$self->offset;my$new_offset=$offsets->[-1];my$event_types=$self->events;if ($new_offset < 0){$new_offset=0}elsif ($self->new_node){if ($event_types->[-1]!~ m/^FLOW/){$new_offset++}}push @{$self->events},'FLOWMAP';push @{$offsets},$new_offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event',style=>YAML_FLOW_MAPPING_STYLE };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($event_stack,$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_flow_sequence {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'sequence_end_event' };$self->callback->($self,$info->{name},$info);$event_types->[-1]=$next_event{$event_types->[-1]}}sub end_flow_mapping {my ($self)=@_;my$event_types=$self->events;pop @{$event_types};pop @{$self->offset};my$info={name=>'mapping_end_event' };$self->callback->($self,$info->{name},$info);$event_types->[-1]=$next_event{$event_types->[-1]}}sub start_mapping {my ($self,$offset)=@_;my$offsets=$self->offset;push @{$self->events},'MAP';push @{$offsets},$offset;my$event_stack=$self->event_stack;my$info={name=>'mapping_start_event' };if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$self->node_properties($properties->[1],$info)}$self->callback->($self,'mapping_start_event',$info)}sub end_document {my ($self,$implicit)=@_;my$event_types=$self->events;if ($event_types->[-1]=~ m/FLOW/){die "Unexpected end of flow context"}if ($self->new_node){$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}$self->remove_nodes(-1);if ($event_types->[-1]eq 'STR'){return}my$last=pop @{$event_types};if ($last ne 'DOC' and $last ne 'DOC_END'){$self->exception("Unexpected event type $last")}pop @{$self->offset};$self->callback->($self,'document_end_event',{name=>'document_end_event',implicit=>$implicit,});if ($self->yaml_version eq '1.2'){$self->set_tagmap({'!!'=>"tag:yaml.org,2002:" })}$event_types->[-1]=$next_event{$event_types->[-1]};$self->set_rule('STREAM')}sub end_stream {my ($self)=@_;my$last=pop @{$self->events};$self->exception("Unexpected event type $last")unless$last eq 'STR';pop @{$self->offset};$self->callback->($self,'stream_end_event',{name=>'stream_end_event',})}sub fetch_inline_properties {my ($self,$stack,$info)=@_;my$properties=$stack->[-1];$properties=$properties->[1];my$property_offset;if ($properties){for my$p (@{$properties->{inline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value};unless (defined$property_offset){$property_offset=$p->{offset};$info->{offset}=$p->{offset}}}delete$properties->{inline};undef$properties unless$properties->{newline}}unless ($properties){pop @$stack}}sub node_properties {my ($self,$properties,$info)=@_;if ($properties){for my$p (@{$properties->{newline}}){my$type=$p->{type};if (exists$info->{$type }){$self->exception("A node can only have one $type")}$info->{$type }=$p->{value}}undef$properties}}sub scalar_event {my ($self,$info)=@_;my$event_types=$self->events;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){my$properties=pop @$event_stack;$properties=$self->node_properties($properties->[1],$info)}$info->{name}='scalar_event';$self->callback->($self,'scalar_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub alias_event {my ($self,$info)=@_;my$event_stack=$self->event_stack;if (@$event_stack and $event_stack->[-1]->[0]eq 'properties'){$self->exception("Parse error: Alias not allowed in this context")}my$event_types=$self->events;$info->{name}='alias_event';$self->callback->($self,'alias_event',$info);$self->set_new_node(0);$event_types->[-1]=$next_event{$event_types->[-1]}}sub yaml_to_tokens {my ($class,$type,$input)=@_;my$yp=YAML::PP::Parser->new(receiver=>sub {});my@docs=eval {$type eq 'string' ? $yp->parse_string($input): $yp->parse_file($input)};my$error=$@;my$tokens=$yp->tokens;if ($error){my$remaining_tokens=$yp->_remaining_tokens;push @$tokens,map {+{%$_,name=>'ERROR' }}@$remaining_tokens}return$error,$tokens}sub _remaining_tokens {my ($self)=@_;my@tokens;my$next=$self->lexer->next_tokens;push@tokens,@$next;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}$remaining .= $self->reader->read;$remaining='' unless defined$remaining;push@tokens,{name=>"ERROR",value=>$remaining };return \@tokens}sub event_to_test_suite {my ($self,$event)=@_;if (ref$event eq 'ARRAY'){return YAML::PP::Common::event_to_test_suite($event->[1])}return YAML::PP::Common::event_to_test_suite($event)}sub debug_events {my ($self)=@_;$self->note("EVENTS: (" .join (' | ',@{$_[0]->events}).')');$self->debug_offset}sub debug_offset {my ($self)=@_;$self->note(qq{OFFSET: (} .join (' | ',map {defined $_ ? sprintf "%-3d",$_ : '?'}@{$_[0]->offset}).qq/) level=@{[ $_[0]->level ]}]}/)}sub debug_yaml {my ($self)=@_;my$line=$self->lexer->line;$self->note("LINE NUMBER: $line");my$next_tokens=$self->lexer->next_tokens;if (@$next_tokens){$self->debug_tokens($next_tokens)}}sub debug_next_line {my ($self)=@_;my$next_line=$self->lexer->next_line || [];my$line=$next_line->[0];$line='' unless defined$line;$line =~ s/( +)$/'' x length $1/e;$line =~ s/\t//g;$self->note("NEXT LINE: >>$line<<")}sub note {my ($self,$msg)=@_;$self->_colorize_warn(["yellow"],"============ $msg")}sub info {my ($self,$msg)=@_;$self->_colorize_warn(["cyan"],"============ $msg")}sub got {my ($self,$msg)=@_;$self->_colorize_warn(["green"],"============ $msg")}sub _colorize_warn {my ($self,$colors,$text)=@_;require Term::ANSIColor;warn Term::ANSIColor::colored($colors,$text),"\n"}sub debug_event {my ($self,$event)=@_;my$str=YAML::PP::Common::event_to_test_suite($event);require Term::ANSIColor;warn Term::ANSIColor::colored(["magenta"],"============ $str"),"\n"}sub debug_rules {my ($self,$rules)=@_;local$Data::Dumper::Maxdepth=2;$self->note("RULES:");for my$rule ($rules){if (ref$rule eq 'ARRAY'){my$first=$rule->[0];if (ref$first eq 'SCALAR'){$self->info("-> $$first")}else {if (ref$first eq 'ARRAY'){$first=$first->[0]}$self->info("TYPE $first")}}else {eval {my@keys=sort keys %$rule;$self->info("@keys")}}}}sub debug_tokens {my ($self,$tokens)=@_;$tokens ||= $self->tokens;require Term::ANSIColor;for my$token (@$tokens){my$type=Term::ANSIColor::colored(["green"],sprintf "%-22s L %2d C %2d ",$token->{name},$token->{line},$token->{column}+ 1);local$Data::Dumper::Useqq=1;local$Data::Dumper::Terse=1;require Data::Dumper;my$str=Data::Dumper->Dump([$token->{value}],['str']);chomp$str;$str =~ s/(^.|.$)/Term::ANSIColor::colored(['blue'], $1)/ge;warn "$type$str\n"}}sub highlight_yaml {my ($self)=@_;require YAML::PP::Highlight;my$tokens=$self->tokens;my$highlighted=YAML::PP::Highlight->ansicolored($tokens);warn$highlighted}sub exception {my ($self,$msg,%args)=@_;my$next=$self->lexer->next_tokens;my$line=@$next ? $next->[0]->{line}: $self->lexer->line;my$offset=@$next ? $next->[0]->{column}: $self->lexer->offset;$offset++;my$next_line=$self->lexer->next_line;my$remaining='';if ($next_line){if ($self->lexer->offset > 0){$remaining=$next_line->[1].$next_line->[2]}else {$remaining=join '',@$next_line}}my$caller=$args{caller}|| [caller(0)];my$e=YAML::PP::Exception->new(got=>$args{got},expected=>$args{expected},line=>$line,column=>$offset,msg=>$msg,next=>$next,where=>$caller->[1].' line ' .$caller->[2],yaml=>$remaining,);croak$e}sub expected {my ($self,%args)=@_;my$expected=$args{expected};@$expected=sort grep {m/^[A-Z_]+$/}@$expected;my$got=$args{got}->{name};my@caller=caller(0);$self->exception("Expected (@$expected), but got $got",caller=>\@caller,expected=>$expected,got=>$args{got},)}sub cb_tag {my ($self,$token)=@_;my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];my$tag=$self->_read_tag($token->{value},$self->tagmap);$last->{inline}||= [];push @{$last->{inline}},{type=>'tag',value=>$tag,offset=>$token->{column},}}sub _read_tag {my ($self,$tag,$map)=@_;if ($tag eq '!'){return "!"}elsif ($tag =~ m/^!<(.*)>/){return $1}elsif ($tag =~ m/^(![^!]*!|!)(.+)/){my$alias=$1;my$name=$2;$name =~ s/%([0-9a-fA-F]{2})/chr hex $1/eg;if (exists$map->{$alias }){$tag=$map->{$alias }.$name}else {if ($alias ne '!' and $alias ne '!!'){die "Found undefined tag handle '$alias'"}$tag="!$name"}}else {die "Invalid tag"}return$tag}sub cb_anchor {my ($self,$token)=@_;my$anchor=$token->{value};$anchor=substr($anchor,1);my$stack=$self->event_stack;if (!@$stack or $stack->[-1]->[0]ne 'properties'){push @$stack,[properties=>{}]}my$last=$stack->[-1]->[1];$last->{inline}||= [];push @{$last->{inline}},{type=>'anchor',value=>$anchor,offset=>$token->{column},}}sub cb_property_eol {my ($self,$res)=@_;my$stack=$self->event_stack;my$last=$stack->[-1]->[1];my$inline=delete$last->{inline}or return;my$newline=$last->{newline}||= [];push @$newline,@$inline}sub cb_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_send_mapkey {my ($self,$res)=@_;my$last=pop @{$self->event_stack};$self->scalar_event($last->[1]);$self->set_new_node(1)}sub cb_send_scalar {my ($self,$res)=@_;my$last=pop @{$self->event_stack};$self->scalar_event($last->[1])}sub cb_empty_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_flow_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);$self->alias_event({value=>$alias })}sub cb_send_alias_from_stack {my ($self,$token)=@_;my$last=pop @{$self->event_stack};$self->alias_event($last->[1])}sub cb_alias {my ($self,$token)=@_;my$alias=substr($token->{value},1);push @{$self->event_stack},[alias=>{value=>$alias,offset=>$token->{column},}]}sub cb_question {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_flow_question {my ($self,$res)=@_}sub cb_empty_complexvalue {my ($self,$res)=@_;$self->scalar_event({style=>YAML_PLAIN_SCALAR_STYLE,value=>'' })}sub cb_questionstart {my ($self,$token)=@_;$self->start_mapping($token->{column})}sub cb_complexcolon {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_seqstart {my ($self,$token)=@_;my$column=$token->{column};$self->start_sequence($column);$self->set_new_node(1)}sub cb_seqitem {my ($self,$res)=@_;$self->set_new_node(1)}sub cb_take_quoted {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_quoted_multiline {my ($self,$token)=@_;my$subtokens=$token->{subtokens};my$stack=$self->event_stack;my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_take_quoted_key {my ($self,$token)=@_;$self->cb_take_quoted($token);$self->cb_send_mapkey}sub cb_send_plain_multi {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_start_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$stack},[scalar=>$info ]}sub cb_start_flowseq {my ($self,$token)=@_;$self->start_flow_sequence($token->{column})}sub cb_start_flowmap {my ($self,$token)=@_;$self->start_flow_mapping($token->{column})}sub cb_end_flowseq {my ($self,$res)=@_;$self->end_flow_sequence;$self->set_new_node(0)}sub cb_flow_comma {my ($self)=@_;my$event_types=$self->events;$self->set_new_node(0);if ($event_types->[-1]=~ m/^FLOWSEQ/){$event_types->[-1]=$next_event{$event_types->[-1]}}}sub cb_flow_colon {my ($self)=@_;$self->set_new_node(1)}sub cb_empty_flow_mapkey {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_end_flowmap {my ($self,$res)=@_;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_end_flowmap_empty {my ($self,$res)=@_;$self->cb_empty_flowmap_value;$self->end_flow_mapping;$self->set_new_node(0)}sub cb_flow_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_flowkey_plain {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_flowkey_quoted {my ($self,$token)=@_;my$stack=$self->event_stack;my$subtokens=$token->{subtokens};my$info={style=>$subtokens->[0]->{value}eq '"' ? YAML_DOUBLE_QUOTED_SCALAR_STYLE : YAML_SINGLE_QUOTED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_empty_flowmap_value {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->scalar_event($info)}sub cb_insert_map_alias {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->alias_event($info);$self->set_new_node(1)}sub cb_insert_map {my ($self,$res)=@_;my$stack=$self->event_stack;my$scalar=pop @$stack;my$info=$scalar->[1];$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_insert_empty_map {my ($self,$token)=@_;my$stack=$self->event_stack;my$info={style=>YAML_PLAIN_SCALAR_STYLE,value=>'',offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}$self->start_mapping($info->{offset});$self->scalar_event($info);$self->set_new_node(1)}sub cb_send_block_scalar {my ($self,$token)=@_;my$type=$token->{subtokens}->[0]->{value};my$stack=$self->event_stack;my$info={style=>$type eq '|' ? YAML_LITERAL_SCALAR_STYLE : YAML_FOLDED_SCALAR_STYLE,value=>$token->{value},offset=>$token->{column},};if (@$stack and $stack->[-1]->[0]eq 'properties'){$self->fetch_inline_properties($stack,$info)}push @{$self->event_stack},[scalar=>$info ];$self->cb_send_scalar}sub cb_end_document {my ($self,$token)=@_;$self->end_document(0)}sub cb_end_document_empty {my ($self,$token)=@_;$self->end_document(0)}sub cb_doc_start_implicit {my ($self,$token)=@_;$self->start_document(1)}sub cb_doc_start_explicit {my ($self,$token)=@_;$self->start_document(0)}sub cb_end_doc_start_document {my ($self,$token)=@_;$self->end_document(1);$self->start_document(0)}sub cb_tag_directive {my ($self,$token)=@_;my ($name,$tag_alias,$tag_url)=split ' ',$token->{value};$self->tagmap->{$tag_alias }=$tag_url}sub cb_reserved_directive {}sub cb_set_yaml_version_directive {my ($self,$token)=@_;if ($self->yaml_version_directive){croak "Found duplicate YAML directive"}my ($version)=$token->{value}=~ m/^%YAML (1\.[12])/;$self->set_yaml_version($version);$self->set_yaml_version_directive(1)}1;
YAML_PP_PARSER

$fatpacked{"YAML/PP/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_PERL';
  use strict;use warnings;package YAML::PP::Perl;our$VERSION='0.027';use base 'Exporter';use base 'YAML::PP';our@EXPORT_OK=qw/Load Dump LoadFile DumpFile/;use YAML::PP;use YAML::PP::Schema::Perl;sub new {my ($class,%args)=@_;$args{schema}||= [qw/Core Perl/];$class->SUPER::new(%args)}sub Load {my ($yaml)=@_;__PACKAGE__->new->load_string($yaml)}sub LoadFile {my ($file)=@_;__PACKAGE__->new->load_file($file)}sub Dump {my (@data)=@_;__PACKAGE__->new->dump_string(@data)}sub DumpFile {my ($file,@data)=@_;__PACKAGE__->new->dump_file($file,@data)}1;
YAML_PP_PERL

$fatpacked{"YAML/PP/Reader.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_READER';
  use strict;use warnings;package YAML::PP::Reader;our$VERSION='0.027';sub input {return $_[0]->{input}}sub set_input {$_[0]->{input}=$_[1]}sub new {my ($class,%args)=@_;my$input=delete$args{input};return bless {input=>$input,},$class}sub read {my ($self)=@_;my$pos=pos$self->{input}|| 0;my$yaml=substr($self->{input},$pos);$self->{input}='';return$yaml}sub readline {my ($self)=@_;unless (length$self->{input}){return}if ($self->{input}=~ m/\G([^\r\n]*(?:\n|\r\n|\r|\z))/g){my$line=$1;unless (length$line){$self->{input}='';return}return$line}return}package YAML::PP::Reader::File;use Scalar::Util qw/openhandle/;our@ISA=qw/YAML::PP::Reader/;use Carp qw/croak/;sub open_handle {if (openhandle($_[0]->{input})){return $_[0]->{input}}open my$fh,'<:encoding(UTF-8)',$_[0]->{input}or croak "Could not open '$_[0]->{input}' for reading: $!";return$fh}sub read {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;if (wantarray){my@yaml=<$fh>;return@yaml}else {local $/;my$yaml=<$fh>;return$yaml}}sub readline {my$fh=$_[0]->{filehandle}||= $_[0]->open_handle;return scalar <$fh>}1;
YAML_PP_READER

$fatpacked{"YAML/PP/Render.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_RENDER';
  use strict;use warnings;package YAML::PP::Render;our$VERSION='0.027';use constant TRACE=>$ENV{YAML_PP_TRACE}? 1 : 0;sub render_quoted {my ($self,$style,$lines)=@_;my$quoted='';my$addspace=0;for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$value=$line->{value};my$last=$i==$#$lines;my$first=$i==0;if ($value eq ''){if ($first){$addspace=1}elsif ($last){$quoted .= ' ' if$addspace}else {$addspace=0;$quoted .= "\n"}next}$quoted .= ' ' if$addspace;$addspace=1;if ($style eq '"'){if ($line->{orig}=~ m/\\$/){$line->{value}=~ s/\\$//;$value =~ s/\\$//;$addspace=0}}$quoted .= $value}return$quoted}sub render_block_scalar {my ($self,$block_type,$chomp,$lines)=@_;my ($folded,$keep,$trim);if ($block_type eq '>'){$folded=1}if ($chomp eq '+'){$keep=1}elsif ($chomp eq '-'){$trim=1}my$string='';if (not $keep){while (@$lines){last if$lines->[-1]ne '';pop @$lines}}if ($folded){my$prev='START';for my$i (0 .. $#$lines){my$line=$lines->[$i ];my$type=$line eq '' ? 'EMPTY' : $line =~ m/\A[ \t]/ ? 'MORE' : 'CONTENT';if ($prev eq 'MORE' and $type eq 'EMPTY'){$type='MORE'}elsif ($prev eq 'CONTENT'){if ($type ne 'CONTENT'){$string .= "\n"}elsif ($type eq 'CONTENT'){$string .= ' '}}elsif ($prev eq 'START' and $type eq 'EMPTY'){$string .= "\n";$type='START'}elsif ($prev eq 'EMPTY' and $type ne 'CONTENT'){$string .= "\n"}$string .= $line;if ($type eq 'MORE' and $i < $#$lines){$string .= "\n"}$prev=$type}$string .= "\n" if @$lines and not $trim}else {for my$i (0 .. $#$lines){$string .= $lines->[$i ];$string .= "\n" if ($i!=$#$lines or not $trim)}}TRACE and warn __PACKAGE__.':'.__LINE__.$".Data::Dumper->Dump([\$string],['string']);return$string}sub render_multi_val {my ($self,$multi)=@_;my$string='';my$start=1;for my$line (@$multi){if (not $start){if ($line eq ''){$string .= "\n";$start=1}else {$string .= " $line"}}else {$string .= $line;$start=0}}return$string}1;
YAML_PP_RENDER

$fatpacked{"YAML/PP/Representer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_REPRESENTER';
  use strict;use warnings;package YAML::PP::Representer;our$VERSION='0.027';use Scalar::Util qw/reftype blessed refaddr/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE YAML_DOUBLE_QUOTED_SCALAR_STYLE YAML_ANY_SCALAR_STYLE YAML_LITERAL_SCALAR_STYLE YAML_FOLDED_SCALAR_STYLE YAML_FLOW_SEQUENCE_STYLE YAML_FLOW_MAPPING_STYLE YAML_BLOCK_MAPPING_STYLE YAML_BLOCK_SEQUENCE_STYLE PRESERVE_ORDER PRESERVE_SCALAR_STYLE PRESERVE_FLOW_STYLE PRESERVE_ALIAS/;use B;sub new {my ($class,%args)=@_;my$preserve=delete$args{preserve}|| 0;if ($preserve==1){$preserve=PRESERVE_ORDER | PRESERVE_SCALAR_STYLE | PRESERVE_FLOW_STYLE | PRESERVE_ALIAS}my$self=bless {schema=>delete$args{schema},preserve=>$preserve,},$class;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}return$self}sub clone {my ($self)=@_;my$clone={schema=>$self->schema,preserve=>$self->{preserve},};return bless$clone,ref$self}sub schema {return $_[0]->{schema}}sub preserve_order {return $_[0]->{preserve}& PRESERVE_ORDER}sub preserve_scalar_style {return $_[0]->{preserve}& PRESERVE_SCALAR_STYLE}sub preserve_flow_style {return $_[0]->{preserve}& PRESERVE_FLOW_STYLE}sub preserve_alias {return $_[0]->{preserve}& PRESERVE_ALIAS}sub represent_node {my ($self,$node)=@_;my$preserve_alias=$self->preserve_alias;my$preserve_style=$self->preserve_scalar_style;if ($preserve_style or $preserve_alias){if (ref$node->{value}eq 'YAML::PP::Preserve::Scalar'){my$value=$node->{value}->value;if ($preserve_style and $node->{value}->style!=YAML_FOLDED_SCALAR_STYLE){$node->{style}=$node->{value}->style}$node->{value}=$value}}$node->{reftype}=reftype($node->{value});if (not $node->{reftype}and reftype(\$node->{value})eq 'GLOB'){$node->{reftype}='GLOB'}if ($node->{reftype}){$self->represent_noderef($node)}else {$self->represent_node_nonref($node)}$node->{reftype}=(reftype$node->{data})|| '';if ($node->{reftype}eq 'HASH' and my$tied=tied(%{$node->{data}})){my$representers=$self->schema->representers;$tied=ref$tied;if (my$def=$representers->{tied_equals}->{$tied }){my$code=$def->{code};my$done=$code->($self,$node)}}if ($node->{reftype}eq 'HASH'){unless (defined$node->{items}){my@keys;if ($self->preserve_order){@keys=keys %{$node->{data}}}else {@keys=sort keys %{$node->{data}}}for my$key (@keys){push @{$node->{items}},$key,$node->{data}->{$key }}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'HASH'){if (my$tied=tied %{$node->{value}}){$args{style}=$tied->{style}}}return [mapping=>$node,%args ]}elsif ($node->{reftype}eq 'ARRAY'){unless (defined$node->{items}){@{$node->{items}}=@{$node->{data}}}my%args;if ($self->preserve_flow_style and reftype$node->{value}eq 'ARRAY'){if (my$tied=tied @{$node->{value}}){$args{style}=$tied->{style}}}return [sequence=>$node,%args ]}elsif ($node->{reftype}){die "Cannot handle reftype '$node->{reftype}' (you might want to enable YAML::PP::Schema::Perl)"}else {unless (defined$node->{items}){$node->{items}=[$node->{data}]}return [scalar=>$node ]}}sub represent_node_nonref {my ($self,$node)=@_;my$representers=$self->schema->representers;if (not defined$node->{value}){if (my$undef=$representers->{undef}){return 1 if$undef->($self,$node)}else {$node->{style}=YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}='';return 1}}for my$rep (@{$representers->{flags}}){my$check_flags=$rep->{flags};my$flags=B::svref_2object(\$node->{value})->FLAGS;if ($flags & $check_flags){return 1 if$rep->{code}->($self,$node)}}if (my$rep=$representers->{equals}->{$node->{value}}){return 1 if$rep->{code}->($self,$node)}for my$rep (@{$representers->{regex}}){if ($node->{value}=~ $rep->{regex}){return 1 if$rep->{code}->($self,$node)}}unless (defined$node->{data}){$node->{data}=$node->{value}}unless (defined$node->{style}){$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{style}=""}}sub represent_noderef {my ($self,$node)=@_;my$representers=$self->schema->representers;if (my$classname=blessed($node->{value})){if (my$def=$representers->{class_equals}->{$classname }){my$code=$def->{code};return 1 if$code->($self,$node)}for my$matches (@{$representers->{class_matches}}){my ($re,$code)=@$matches;if (ref$re and $classname =~ $re or $re){return 1 if$code->($self,$node)}}for my$isa (@{$representers->{class_isa}}){my ($class_name,$code)=@$isa;if ($node->{value }->isa($class_name)){return 1 if$code->($self,$node)}}}if ($node->{reftype}eq 'SCALAR' and my$scalarref=$representers->{scalarref}){my$code=$scalarref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'REF' and my$refref=$representers->{refref}){my$code=$refref->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'CODE' and my$coderef=$representers->{coderef}){my$code=$coderef->{code};return 1 if$code->($self,$node)}if ($node->{reftype}eq 'GLOB' and my$glob=$representers->{glob}){my$code=$glob->{code};return 1 if$code->($self,$node)}$node->{data}=$node->{value}}1;
YAML_PP_REPRESENTER

$fatpacked{"YAML/PP/Schema.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA';
  use strict;use warnings;package YAML::PP::Schema;use B;use Module::Load qw//;our$VERSION='0.027';use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;use Scalar::Util qw/blessed/;sub new {my ($class,%args)=@_;my$yaml_version=delete$args{yaml_version};my$bool=delete$args{boolean};$bool='perl' unless defined$bool;if (keys%args){die "Unexpected arguments: " .join ', ',sort keys%args}my$true;my$false;my$bool_class='';if ($bool eq 'JSON::PP'){require JSON::PP;$true=\&bool_jsonpp_true;$false=\&bool_jsonpp_false;$bool_class='JSON::PP::Boolean'}elsif ($bool eq 'boolean'){require boolean;$true=\&bool_booleanpm_true;$false=\&bool_booleanpm_false;$bool_class='boolean'}elsif ($bool eq 'perl'){$true=\&bool_perl_true;$false=\&bool_perl_false}else {die "Invalid value for 'boolean': '$bool'. Allowed: ('perl', 'boolean', 'JSON::PP')"}my%representers=('undef'=>undef,flags=>[],equals=>{},regex=>[],class_equals=>{},class_matches=>[],class_isa=>[],scalarref=>undef,refref=>undef,coderef=>undef,glob=>undef,tied_equals=>{},);my$self=bless {yaml_version=>$yaml_version,resolvers=>{},representers=>\%representers,true=>$true,false=>$false,bool_class=>$bool_class,},$class;return$self}sub resolvers {return $_[0]->{resolvers}}sub representers {return $_[0]->{representers}}sub true {return $_[0]->{true}}sub false {return $_[0]->{false}}sub bool_class {return $_[0]->{bool_class}}sub yaml_version {return $_[0]->{yaml_version}}my%LOADED_SCHEMA=(JSON=>1,);my%DEFAULT_SCHEMA=('1.2'=>'Core','1.1'=>'YAML1_1',);sub load_subschemas {my ($self,@schemas)=@_;my$yaml_version=$self->yaml_version;my$i=0;while ($i < @schemas){my$item=$schemas[$i ];if ($item eq '+'){$item=$DEFAULT_SCHEMA{$yaml_version }}$i++;if (blessed($item)){$item->register(schema=>$self,);next}my@options;while ($i < @schemas and ($schemas[$i ]=~ m/^[^A-Za-z]/ or $schemas[$i ]=~ m/^[a-zA-Z0-9]+=/)){push@options,$schemas[$i ];$i++}my$class;if ($item =~ m/^\:(.*)/){$class="$1";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}Module::Load::load$class}else {$class="YAML::PP::Schema::$item";unless ($class =~ m/\A[A-Za-z0-9_:]+\z/){die "Module name '$class' is invalid"}$LOADED_SCHEMA{$item }||= Module::Load::load$class}$class->register(schema=>$self,options=>\@options,)}}sub add_resolver {my ($self,%args)=@_;my$tag=$args{tag};my$rule=$args{match};my$resolvers=$self->resolvers;my ($type,@rule)=@$rule;my$implicit=$args{implicit};$implicit=1 unless defined$implicit;my$resolver_list=[];if ($tag){if (ref$tag eq 'Regexp'){my$res=$resolvers->{tags}||= [];push @$res,[$tag,{}];push @$resolver_list,$res->[-1]->[1]}else {my$res=$resolvers->{tag}->{$tag }||= {};push @$resolver_list,$res}}if ($implicit){push @$resolver_list,$resolvers->{value}||= {}}for my$res (@$resolver_list){if ($type eq 'equals'){my ($match,$value)=@rule;unless (exists$res->{equals}->{$match }){$res->{equals}->{$match }=$value}next}elsif ($type eq 'regex'){my ($match,$value)=@rule;push @{$res->{regex}},[$match=>$value ]}elsif ($type eq 'all'){my ($value)=@rule;$res->{all}=$value}}}sub add_sequence_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(sequence=>%args)}sub add_mapping_resolver {my ($self,%args)=@_;return$self->add_collection_resolver(mapping=>%args)}sub add_collection_resolver {my ($self,$type,%args)=@_;my$tag=$args{tag};my$implicit=$args{implicit};my$resolvers=$self->resolvers;if ($tag and ref$tag eq 'Regexp'){my$res=$resolvers->{$type }->{tags}||= [];push @$res,[$tag,{on_create=>$args{on_create},on_data=>$args{on_data},}]}elsif ($tag){my$res=$resolvers->{$type }->{tag}->{$tag }||= {on_create=>$args{on_create},on_data=>$args{on_data},}}}sub add_representer {my ($self,%args)=@_;my$representers=$self->representers;if (my$flags=$args{flags}){my$rep=$representers->{flags};push @$rep,\%args;return}if (my$regex=$args{regex}){my$rep=$representers->{regex};push @$rep,\%args;return}if (my$regex=$args{class_matches}){my$rep=$representers->{class_matches};push @$rep,[$args{class_matches},$args{code}];return}if (my$class_equals=$args{class_equals}){my$rep=$representers->{class_equals};$rep->{$class_equals }={code=>$args{code},};return}if (my$class_isa=$args{class_isa}){my$rep=$representers->{class_isa};push @$rep,[$args{class_isa},$args{code}];return}if (my$tied_equals=$args{tied_equals}){my$rep=$representers->{tied_equals};$rep->{$tied_equals }={code=>$args{code},};return}if (defined(my$equals=$args{equals})){my$rep=$representers->{equals};$rep->{$equals }={code=>$args{code},};return}if (defined(my$scalarref=$args{scalarref})){$representers->{scalarref}={code=>$args{code},};return}if (defined(my$refref=$args{refref})){$representers->{refref}={code=>$args{code},};return}if (defined(my$coderef=$args{coderef})){$representers->{coderef}={code=>$args{code},};return}if (defined(my$glob=$args{glob})){$representers->{glob}={code=>$args{code},};return}if (my$undef=$args{undefined}){$representers->{undef}=$undef;return}}sub load_scalar {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$value=$event->{value};my$resolvers=$self->resolvers;my$res;if ($tag){$res=$resolvers->{tag}->{$tag };if (not $res and my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$rule)=@$match;if ($tag =~ $re){$res=$rule;last}}}}else {$res=$resolvers->{value};if ($event->{style}ne YAML_PLAIN_SCALAR_STYLE){return$value}}if (my$equals=$res->{equals}){if (exists$equals->{$value }){my$res=$equals->{$value };if (ref$res eq 'CODE'){return$res->($constructor,$event)}return$res}}if (my$regex=$res->{regex}){for my$item (@$regex){my ($re,$sub)=@$item;my@matches=$value =~ $re;if (@matches){return$sub->($constructor,$event,\@matches)}}}if (my$catch_all=$res->{all}){if (ref$catch_all eq 'CODE'){return$catch_all->($constructor,$event)}return$catch_all}return$value}sub create_sequence {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data=[];my$on_data;my$resolvers=$self->resolvers->{sequence};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub create_mapping {my ($self,$constructor,$event)=@_;my$tag=$event->{tag};my$data={};my$on_data;my$resolvers=$self->resolvers->{mapping};if ($tag){if (my$equals=$resolvers->{tag}->{$tag }){my$on_create=$equals->{on_create};$on_data=$equals->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}if (my$matches=$resolvers->{tags}){for my$match (@$matches){my ($re,$actions)=@$match;my$on_create=$actions->{on_create};if ($tag =~ $re){$on_data=$actions->{on_data};$on_create and $data=$on_create->($constructor,$event);return ($data,$on_data)}}}}return ($data,$on_data)}sub bool_jsonpp_true {JSON::PP::true()}sub bool_booleanpm_true {boolean::true()}sub bool_perl_true {1}sub bool_jsonpp_false {JSON::PP::false()}sub bool_booleanpm_false {boolean::false()}sub bool_perl_false {!1}1;
YAML_PP_SCHEMA

$fatpacked{"YAML/PP/Schema/Binary.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_BINARY';
  use strict;use warnings;package YAML::PP::Schema::Binary;our$VERSION='0.027';use MIME::Base64 qw/decode_base64 encode_base64/;use YAML::PP::Common qw/YAML_ANY_SCALAR_STYLE/;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:binary',match=>[all=>sub {my ($constructor,$event)=@_;my$base64=$event->{value};my$binary=decode_base64($base64);return$binary}],implicit=>0,);$schema->add_representer(regex=>qr{.*},code=>sub {my ($rep,$node)=@_;my$binary=$node->{value};unless ($binary =~ m/[\x{7F}-\x{10FFFF}]/){return}if (utf8::is_utf8($binary)){return}my$base64=encode_base64($binary);$node->{style}=YAML_ANY_SCALAR_STYLE;$node->{data}=$base64;$node->{tag}="tag:yaml.org,2002:binary";return 1},)}1;
YAML_PP_SCHEMA_BINARY

$fatpacked{"YAML/PP/Schema/Core.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_CORE';
  use strict;use warnings;package YAML::PP::Schema::Core;our$VERSION='0.027';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_CORE=qr{^([+-]?(?:[0-9]+))$};my$RE_FLOAT_CORE=qr{^([+-]?(?:\.[0-9]+|[0-9]+(?:\.[0-9]*)?)(?:[eE][+-]?[0-9]+)?)$};my$RE_INT_OCTAL=qr{^0o([0-7]+)$};my$RE_INT_HEX=qr{^0x([0-9a-fA-F]+)$};sub _from_oct {oct $_[2]->[0]}sub _from_hex {hex $_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_CORE=>\&YAML::PP::Schema::JSON::_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_CORE=>\&YAML::PP::Schema::JSON::_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True false FALSE False null NULL Null ~ .inf .Inf .INF +.inf +.Inf +.INF -.inf -.Inf -.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_CORE|$RE_FLOAT_CORE|$RE_INT_OCTAL|$RE_INT_HEX},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}1;
YAML_PP_SCHEMA_CORE

$fatpacked{"YAML/PP/Schema/Failsafe.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_FAILSAFE';
  use strict;use warnings;package YAML::PP::Schema::Failsafe;our$VERSION='0.027';sub register {my ($self,%args)=@_;return}1;
YAML_PP_SCHEMA_FAILSAFE

$fatpacked{"YAML/PP/Schema/Include.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_INCLUDE';
  use strict;use warnings;package YAML::PP::Schema::Include;our$VERSION='0.027';use Carp qw/croak/;use Scalar::Util qw/weaken/;use File::Basename qw/dirname/;sub new {my ($class,%args)=@_;my$paths=delete$args{paths};if (defined$paths){unless (ref$paths eq 'ARRAY'){$paths=[$paths]}}else {$paths=[]}my$allow_absolute=$args{allow_absolute}|| 0;my$loader=$args{loader}|| \&default_loader;my$self=bless {paths=>$paths,allow_absolute=>$allow_absolute,last_includes=>[],cached=>{},loader=>$loader,},$class;return$self}sub init {my ($self)=@_;$self->{last_includes}=[];$self->{cached}=[]}sub paths {$_[0]->{paths}}sub allow_absolute {$_[0]->{allow_absolute}}sub yp {my ($self,$yp)=@_;if (@_==2){$self->{yp}=$yp;weaken$self->{yp};return$yp}return$self->{yp}}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'!include',match=>[all=>sub {$self->include(@_)}],implicit=>0,)}sub include {my ($self,$constructor,$event)=@_;my$yp=$self->yp;my$search_paths=$self->paths;my$allow_absolute=$self->allow_absolute;my$relative=not @$search_paths;if ($relative){my$last_includes=$self->{last_includes};if (@$last_includes){$search_paths=[$last_includes->[-1]]}else {my$filename=$yp->loader->filename;$search_paths=[dirname$filename]}}my$filename=$event->{value};my$fullpath;if (File::Spec->file_name_is_absolute($filename)){unless ($allow_absolute){croak "Absolute filenames not allowed"}$fullpath=$filename}else {my@paths=File::Spec->splitdir($filename);unless ($allow_absolute){@paths=File::Spec->no_upwards(@paths)}for my$candidate (@$search_paths){my$test=File::Spec->catfile($candidate,@paths);if (-e $test){$fullpath=$test;last}}croak "File '$filename' not found" unless defined$fullpath}if ($self->{cached}->{$fullpath }++){croak "Circular include '$fullpath'"}if ($relative){push @{$self->{last_includes}},dirname$fullpath}my$clone=$yp->clone;my ($data)=$self->loader->($clone,$fullpath);if ($relative){pop @{$self->{last_includes}}}unless (--$self->{cached}->{$fullpath }){delete$self->{cached}->{$fullpath }}return$data}sub loader {my ($self,$code)=@_;if (@_==2){$self->{loader}=$code;return$code}return$self->{loader}}sub default_loader {my ($yp,$filename)=@_;$yp->load_file($filename)}1;
YAML_PP_SCHEMA_INCLUDE

$fatpacked{"YAML/PP/Schema/JSON.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_JSON';
  use strict;use warnings;package YAML::PP::Schema::JSON;our$VERSION='0.027';use base 'Exporter';our@EXPORT_OK=qw/represent_int represent_float represent_literal represent_bool represent_undef/;use B;use Carp qw/croak/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE YAML_SINGLE_QUOTED_SCALAR_STYLE/;my$RE_INT=qr{^(-?(?:0|[1-9][0-9]*))$};my$RE_FLOAT=qr{^(-?(?:0|[1-9][0-9]*)(?:\.[0-9]*)?(?:[eE][+-]?[0-9]+)?)$};sub _to_int {0 + $_[2]->[0]}sub _to_float {unpack F=>pack F=>$_[2]->[0]}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$options=$args{options};my$empty_null=0;for my$opt (@$options){if ($opt eq 'empty=str'){}elsif ($opt eq 'empty=null'){$empty_null=1}else {croak "Invalid option for JSON Schema: '$opt'"}}$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>null=>undef ],);if ($empty_null){$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>''=>undef ],implicit=>1,)}else {$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[equals=>''=>'' ],implicit=>1,)}$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>true=>$schema->true ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>false=>$schema->false ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],);$schema->add_representer(undefined=>\&represent_undef,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true false null/);$schema->add_representer(regex=>qr{$RE_INT|$RE_FLOAT},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}sub represent_undef {my ($rep,$node)=@_;$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}='null';return 1}sub represent_literal {my ($rep,$node)=@_;$node->{style}||= YAML_SINGLE_QUOTED_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_int {my ($rep,$node)=@_;if (int($node->{value})ne $node->{value}){return 0}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}my%special=((0+'nan').''=>'.nan',(0+'inf').''=>'.inf',(0-'inf').''=>'-.inf');sub represent_float {my ($rep,$node)=@_;if (exists$special{$node->{value}}){$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}=$special{$node->{value}};return 1}if (0.0 + $node->{value}ne $node->{value}){return 0}if (int($node->{value})eq $node->{value}and not $node->{value}=~ m/\./){$node->{value}.= '.0'}$node->{style}=YAML_PLAIN_SCALAR_STYLE;$node->{data}="$node->{value}";return 1}sub represent_bool {my ($rep,$node)=@_;my$string=$node->{value}? 'true' : 'false';$node->{style}=YAML_PLAIN_SCALAR_STYLE;@{$node->{items}}=$string;$node->{data}=$string;return 1}1;
YAML_PP_SCHEMA_JSON

$fatpacked{"YAML/PP/Schema/Merge.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_MERGE';
  use strict;use warnings;package YAML::PP::Schema::Merge;our$VERSION='0.027';use YAML::PP::Type::MergeKey;sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:merge',match=>[equals=>'<<'=>YAML::PP::Type::MergeKey->new ],)}1;
YAML_PP_SCHEMA_MERGE

$fatpacked{"YAML/PP/Schema/Perl.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_PERL';
  use strict;use warnings;package YAML::PP::Schema::Perl;our$VERSION='0.027';use Scalar::Util qw/blessed reftype/;my$qr_prefix;{$qr_prefix=qr{\(\?-xism\:};if ($] >= 5.014){$qr_prefix=qr{\(\?\^(?:[uadl])?\:}}}sub new {my ($class,%args)=@_;my$tags=$args{tags}|| [];my$loadcode=$args{loadcode};$loadcode ||= 0;my$classes=$args{classes};my$self=bless {tags=>$tags,loadcode=>$loadcode,classes=>$classes,},$class}sub register {my ($self,%args)=@_;my$schema=$args{schema};my$tags;my$loadcode=0;my$classes;if (blessed($self)){$tags=$self->{tags};@$tags=('!perl')unless @$tags;$loadcode=$self->{loadcode};$classes=$self->{classes}}else {my$options=$args{options};my$tagtype='!perl';for my$option (@$options){if ($option =~ m/^tags?=(.+)$/){$tagtype=$1}elsif ($option eq '+loadcode'){$loadcode=1}}$tags=[split m/\+/,$tagtype]}my$perl_tag;my%tagtypes;my@perl_tags;for my$type (@$tags){if ($type eq '!perl'){$perl_tag ||= $type;push@perl_tags,'!perl'}elsif ($type eq '!!perl'){$perl_tag ||= 'tag:yaml.org,2002:perl';push@perl_tags,'tag:yaml.org,2002:perl'}else {die "Invalid tagtype '$type'"}$tagtypes{$type }=1}my$perl_regex='!perl';if ($tagtypes{'!perl'}and $tagtypes{'!!perl'}){$perl_regex='(?:tag:yaml\\.org,2002:|!)perl'}elsif ($tagtypes{'!perl'}){$perl_regex='!perl'}elsif ($tagtypes{'!!perl'}){$perl_regex='tag:yaml\\.org,2002:perl'}my$class_regex=qr{.+};my$no_objects=0;if ($classes){if (@$classes){$class_regex='(' .join('|',map "\Q$_\E",@$classes).')'}else {$no_objects=1;$class_regex=''}}if ($loadcode){my$load_code=sub {my ($constructor,$event)=@_;return$self->evaluate_code($event->{value})};my$load_code_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};my$sub=$self->evaluate_code($event->{value});return$self->object($sub,$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$load_code],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$load_code_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$load_code ],implicit=>0,)if$no_objects}else {my$loadcode_dummy=sub {return sub {}};my$loadcode_blessed_dummy=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/code:}{};return$self->object(sub {},$class)};$schema->add_resolver(tag=>"$_/code",match=>[all=>$loadcode_dummy ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/code:$class_regex$},match=>[all=>$loadcode_blessed_dummy ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/code:.+},match=>[all=>$loadcode_dummy ],implicit=>0,)if$no_objects}my$load_glob=sub {my$value=undef;return \$value};my$load_glob_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/glob:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/glob",on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)for@perl_tags;if ($no_objects){$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:.+$},on_create=>$load_glob,on_data=>sub {my ($constructor,$ref,$list)=@_;$$ref=$self->construct_glob($list)},)}else {$schema->add_mapping_resolver(tag=>qr{^$perl_regex/glob:$class_regex$},on_create=>$load_glob_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_glob($list)},)}my$load_regex=sub {my ($constructor,$event)=@_;return$self->construct_regex($event->{value})};my$load_regex_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/regexp:}{};my$qr=$self->construct_regex($event->{value});return$self->object($qr,$class)};$schema->add_resolver(tag=>"$_/regexp",match=>[all=>$load_regex ],implicit=>0,)for@perl_tags;$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex_blessed ],implicit=>0,);$schema->add_resolver(tag=>qr{^$perl_regex/regexp:$class_regex$},match=>[all=>$load_regex ],implicit=>0,)if$no_objects;my$load_sequence=sub {return []};my$load_sequence_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/array:}{};return$self->object([],$class)};$schema->add_sequence_resolver(tag=>"$_/array",on_create=>$load_sequence,)for@perl_tags;$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:$class_regex$},on_create=>$load_sequence_blessed,);$schema->add_sequence_resolver(tag=>qr{^$perl_regex/array:.+$},on_create=>$load_sequence,)if$no_objects;my$load_mapping=sub {return {}};my$load_mapping_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/hash:}{};return$self->object({},$class)};$schema->add_mapping_resolver(tag=>"$_/hash",on_create=>$load_mapping,)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:$class_regex$},on_create=>$load_mapping_blessed,);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/hash:.+$},on_create=>$load_mapping,)if$no_objects;my$load_ref=sub {my$value=undef;return \$value};my$load_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/ref:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/ref",on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:$class_regex$},on_create=>$load_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/ref:.+$},on_create=>$load_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_ref($list)},)if$no_objects;my$load_scalar_ref=sub {my$value=undef;return \$value};my$load_scalar_ref_blessed=sub {my ($constructor,$event)=@_;my$class=$event->{tag};$class =~ s{^$perl_regex/scalar:}{};my$value=undef;return$self->object(\$value,$class)};$schema->add_mapping_resolver(tag=>"$_/scalar",on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)for@perl_tags;$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:$class_regex$},on_create=>$load_scalar_ref_blessed,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},);$schema->add_mapping_resolver(tag=>qr{^$perl_regex/scalar:.+$},on_create=>$load_scalar_ref,on_data=>sub {my ($constructor,$ref,$list)=@_;$$$ref=$self->construct_scalar($list)},)if$no_objects;$schema->add_representer(scalarref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/scalar";$node->{data}=$self->represent_scalar($node->{value})},);$schema->add_representer(refref=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/ref";$node->{data}=$self->represent_ref($node->{value})},);$schema->add_representer(coderef=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/code";$node->{data}=$self->represent_code($node->{value})},);$schema->add_representer(glob=>1,code=>sub {my ($rep,$node)=@_;$node->{tag}=$perl_tag ."/glob";$node->{data}=$self->represent_glob($node->{value})},);$schema->add_representer(class_matches=>1,code=>sub {my ($rep,$node)=@_;my$blessed=blessed$node->{value};my$tag_blessed=":$blessed";if ($blessed !~ m/^$class_regex$/){$tag_blessed=''}$node->{tag}=sprintf "$perl_tag/%s%s",lc($node->{reftype}),$tag_blessed;if ($node->{reftype}eq 'HASH'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'ARRAY'){$node->{data}=$node->{value}}elsif ($node->{reftype}eq 'REGEXP'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag ."/regexp"}$node->{data}=$self->represent_regex($node->{value})}elsif ($node->{reftype}eq 'SCALAR'){if ($blessed eq 'Regexp'){$node->{tag}=$perl_tag .'/regexp';$node->{data}=$self->represent_regex($node->{value})}elsif ($] <= 5.010001 and not defined ${$node->{value}}and $node->{value}=~ m/^\(\?/){$node->{tag}=$perl_tag .'/regexp' .$tag_blessed;$node->{data}=$self->represent_regex($node->{value})}else {$node->{data}=$self->represent_scalar($node->{value})}}elsif ($node->{reftype}eq 'REF'){$node->{data}=$self->represent_ref($node->{value})}elsif ($node->{reftype}eq 'CODE'){$node->{data}=$self->represent_code($node->{value})}elsif ($node->{reftype}eq 'GLOB'){$node->{data}=$self->represent_glob($node->{value})}else {die "Reftype '$node->{reftype}' not implemented"}return 1},);return}sub evaluate_code {my ($self,$code)=@_;unless ($code =~ m/^ \s* \{ .* \} \s* \z/xs){die "Malformed code"}$code="sub $code";my$sub=eval$code;if ($@){die "Couldn't eval code: $@>>$code<<"}return$sub}sub construct_regex {my ($self,$regex)=@_;if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}my$qr=qr{$regex};return$qr}sub construct_glob {my ($self,$list)=@_;if (@$list % 2){die "Unexpected data in perl/glob construction"}my%globdata=@$list;my$name=delete$globdata{NAME}or die "Missing NAME in perl/glob";my$pkg=delete$globdata{PACKAGE};$pkg='main' unless defined$pkg;my@allowed=qw(SCALAR ARRAY HASH CODE IO);delete@globdata{@allowed };if (my@keys=keys%globdata){die "Unexpected keys in perl/glob: @keys"}no strict 'refs';return *{"${pkg}::$name"}}sub construct_scalar {my ($self,$list)=@_;if (@$list!=2){die "Unexpected data in perl/scalar construction"}my ($key,$value)=@$list;unless ($key eq '='){die "Unexpected data in perl/scalar construction"}return$value}sub construct_ref {&construct_scalar}sub represent_scalar {my ($self,$value)=@_;return {'='=>$$value }}sub represent_ref {&represent_scalar}sub represent_code {my ($self,$code)=@_;require B::Deparse;my$deparse=B::Deparse->new("-p","-sC");return$deparse->coderef2text($code)}my@stats=qw/device inode mode links uid gid rdev size atime mtime ctime blksize blocks/;sub represent_glob {my ($self,$glob)=@_;my%glob;for my$type (qw/PACKAGE NAME SCALAR ARRAY HASH CODE IO/){my$value=*{$glob}{$type};if ($type eq 'SCALAR'){$value=$$value}elsif ($type eq 'IO'){if (defined$value){undef$value;$value->{stat}={};if ($value->{fileno}=fileno(*{$glob})){@{$value->{stat}}{@stats }=stat(*{$glob});$value->{tell}=tell *{$glob}}}}$glob{$type }=$value if defined$value}return \%glob}sub represent_regex {my ($self,$regex)=@_;$regex="$regex";if ($regex =~ m/^$qr_prefix(.*)\)\z/s){$regex=$1}return$regex}sub object {my ($self,$data,$class)=@_;return bless$data,$class}1;
YAML_PP_SCHEMA_PERL

$fatpacked{"YAML/PP/Schema/Tie/IxHash.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_TIE_IXHASH';
  use strict;use warnings;package YAML::PP::Schema::Tie::IxHash;our$VERSION='0.027';use base 'YAML::PP::Schema';use Scalar::Util qw/blessed reftype/;my$ixhash=eval {require Tie::IxHash};sub register {my ($self,%args)=@_;my$schema=$args{schema};unless ($ixhash){die "You need to install Tie::IxHash in order to use this module"}$schema->add_representer(tied_equals=>'Tie::IxHash',code=>sub {my ($rep,$node)=@_;$node->{items}=[%{$node->{data}}];return 1},);return}1;
YAML_PP_SCHEMA_TIE_IXHASH

$fatpacked{"YAML/PP/Schema/YAML1_1.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_SCHEMA_YAML1_1';
  use strict;use warnings;package YAML::PP::Schema::YAML1_1;our$VERSION='0.027';use YAML::PP::Schema::JSON qw/represent_int represent_float represent_literal represent_bool represent_undef/;use YAML::PP::Common qw/YAML_PLAIN_SCALAR_STYLE/;my$RE_INT_1_1=qr{^([+-]?(?:0|[1-9][0-9_]*))$};my$RE_FLOAT_1_1=qr{^([+-]?(?:[0-9][0-9_]*)?\.[0-9_]*(?:[eE][+-][0-9]+)?)$};my$RE_SEXAGESIMAL=qr{^([+-]?[0-9][0-9_]*(:[0-5]?[0-9])+\.[0-9_]*)$};my$RE_SEXAGESIMAL_INT=qr{^([-+]?[1-9][0-9_]*(:[0-5]?[0-9])+)$};my$RE_INT_OCTAL_1_1=qr{^([+-]?)0([0-7_]+)$};my$RE_INT_HEX_1_1=qr{^([+-]?)(0x[0-9a-fA-F_]+)$};my$RE_INT_BIN_1_1=qr{^([-+]?)(0b[0-1_]+)$};sub _from_oct {my ($constructor,$event,$matches)=@_;my ($sign,$oct)=@$matches;$oct =~ tr/_//d;my$result=oct$oct;$result=-$result if$sign eq '-';return$result}sub _from_hex {my ($constructor,$event,$matches)=@_;my ($sign,$hex)=@$matches;my$result=hex$hex;$result=-$result if$sign eq '-';return$result}sub _sexa_to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;my$result=0;my$i=0;my$sign=1;$float =~ s/^-// and $sign=-1;for my$part (reverse split m/:/,$float){$result += $part * (60 ** $i);$i++}$result=unpack F=>pack F=>$result;return$result * $sign}sub _to_float {my ($constructor,$event,$matches)=@_;my ($float)=@$matches;$float =~ tr/_//d;$float=unpack F=>pack F=>$float;return$float}sub _to_int {my ($constructor,$event,$matches)=@_;my ($int)=@$matches;$int =~ tr/_//d;0 + $int}sub register {my ($self,%args)=@_;my$schema=$args{schema};$schema->add_resolver(tag=>'tag:yaml.org,2002:null',match=>[equals=>$_=>undef ],)for (qw/null NULL Null ~/,'');$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->true ],)for (qw/true TRUE True y Y yes Yes YES on On ON/);$schema->add_resolver(tag=>'tag:yaml.org,2002:bool',match=>[equals=>$_=>$schema->false ],)for (qw/false FALSE False n N no No NO off Off OFF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_OCTAL_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_1_1=>\&_to_int ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_HEX_1_1=>\&_from_hex ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_FLOAT_1_1=>\&_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_INT_BIN_1_1=>\&_from_oct ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:int',match=>[regex=>$RE_SEXAGESIMAL_INT=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[regex=>$RE_SEXAGESIMAL=>\&_sexa_to_float ],);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "inf" ],)for (qw/.inf .Inf .INF +.inf +.Inf +.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 - "inf" ],)for (qw/-.inf -.Inf -.INF/);$schema->add_resolver(tag=>'tag:yaml.org,2002:float',match=>[equals=>$_=>0 + "nan" ],)for (qw/.nan .NaN .NAN/);$schema->add_resolver(tag=>'tag:yaml.org,2002:str',match=>[all=>sub {$_[1]->{value}}],implicit=>0,);my$int_flags=B::SVp_IOK;my$float_flags=B::SVp_NOK;$schema->add_representer(flags=>$int_flags,code=>\&represent_int,);$schema->add_representer(flags=>$float_flags,code=>\&represent_float,);$schema->add_representer(undefined=>\&represent_undef,);$schema->add_representer(equals=>$_,code=>\&represent_literal,)for ("",qw/true TRUE True y Y yes Yes YES on On ON false FALSE False n N n no No NO off Off OFF null NULL Null ~ .inf .Inf .INF -.inf -.Inf -.INF +.inf +.Inf +.INF .nan .NaN .NAN/);$schema->add_representer(regex=>qr{$RE_INT_1_1|$RE_FLOAT_1_1|$RE_INT_OCTAL_1_1|$RE_INT_HEX_1_1|$RE_INT_BIN_1_1|$RE_SEXAGESIMAL_INT|$RE_SEXAGESIMAL},code=>\&represent_literal,);if ($schema->bool_class){$schema->add_representer(class_equals=>$schema->bool_class,code=>\&represent_bool,)}return}1;
YAML_PP_SCHEMA_YAML1_1

$fatpacked{"YAML/PP/Type/MergeKey.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_TYPE_MERGEKEY';
  use strict;use warnings;package YAML::PP::Type::MergeKey;our$VERSION='0.027';sub new {my ($class)=@_;return bless {},$class}1;
YAML_PP_TYPE_MERGEKEY

$fatpacked{"YAML/PP/Writer.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER';
  use strict;use warnings;package YAML::PP::Writer;our$VERSION='0.027';sub output {return $_[0]->{output}}sub set_output {$_[0]->{output}=$_[1]}sub new {my ($class,%args)=@_;my$output=delete$args{output};$output='' unless defined$output;return bless {output=>$output,},$class}sub write {my ($self,$line)=@_;$self->{output}.= $line}sub init {$_[0]->set_output('')}sub finish {my ($self)=@_;$_[0]->set_output(undef)}1;
YAML_PP_WRITER

$fatpacked{"YAML/PP/Writer/File.pm"} = '#line '.(1+__LINE__).' "'.__FILE__."\"\n".<<'YAML_PP_WRITER_FILE';
  use strict;use warnings;package YAML::PP::Writer::File;our$VERSION='0.027';use Scalar::Util qw/openhandle/;use base qw/YAML::PP::Writer/;use Carp qw/croak/;sub _open_handle {my ($self)=@_;if (openhandle($self->{output})){$self->{filehandle}=$self->{output};return$self->{output}}open my$fh,'>:encoding(UTF-8)',$self->{output}or croak "Could not open '$self->{output}' for writing: $!";$self->{filehandle}=$fh;return$fh}sub write {my ($self,$line)=@_;my$fh=$self->{filehandle};print$fh $line}sub init {my ($self)=@_;my$fh=$self->_open_handle}sub finish {my ($self)=@_;if (openhandle($self->{output})){return}close$self->{filehandle}}1;
YAML_PP_WRITER_FILE

s/^  //mg for values %fatpacked;

my $class = 'FatPacked::'.(0+\%fatpacked);
no strict 'refs';
*{"${class}::files"} = sub { keys %{$_[0]} };

if ($] < 5.008) {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      my $pos = 0;
      my $last = length $fat;
      return (sub {
        return 0 if $pos == $last;
        my $next = (1 + index $fat, "\n", $pos) || $last;
        $_ .= substr $fat, $pos, $next - $pos;
        $pos = $next;
        return 1;
      });
    }
  };
}

else {
  *{"${class}::INC"} = sub {
    if (my $fat = $_[0]{$_[1]}) {
      open my $fh, '<', \$fat
        or die "FatPacker error loading $_[1] (could be a perl installation issue?)";
      return $fh;
    }
    return;
  };
}

unshift @INC, bless \%fatpacked, $class;
  } # END OF FATPACK CODE

use strict;
use warnings;

use YAML::PP::Loader;
use File::Basename ();

my $file = shift;

eval { YAML::PP::Loader->new->load_file($file) };
my $err = $@;
exit if !$err;

my ($line)   = $err =~ /^Line\s*:\s*(\d+)/m;
my ($column) = $err =~ /^Column\s*:\s*(\d+)/m;

if (defined $line && defined $column) {
    my $base = File::Basename::basename $file;
    print "$base:$line:$column: invalid yaml\n";
}
